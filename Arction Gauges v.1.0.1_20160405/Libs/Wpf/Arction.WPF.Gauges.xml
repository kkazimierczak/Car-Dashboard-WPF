<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Arction.WPF.Gauges</name>
    </assembly>
    <members>
        <member name="T:Arction.Gauges.Accessory.FontData">
            <summary>
             Structure that holds the normal WPF font data in a singel object, and 
             offers comparison tools.
            </summary>
        </member>
        <member name="T:Arction.Gauges.Common.Accessory.FPSCounter">
            <summary>
             Provides infromation of the application "framerate". 
            </summary>
            <Remarks>
            
             <p>After first started (created), receives 
             CopositionTarget.RenderingEvent events and calculates the average 
             FPS from them.</p>
             <p>On WPF StopWatch class is used as time source.</p>
             <p>On Silverlight Environment.TickCount is used as time source. 
             The resolution of the property is said (on forums) to be 16ms.</p>
             <p>The result is probably not really a framerate.
             Note that this is a singleton, and modifying settings of a one 
             counter affects all the others. </p>
             <p>The limiting of the frame data queue is done on the eventcall, 
             thus it slows down the rendering slightly.</p>
            </Remarks>
        </member>
        <member name="M:Arction.Gauges.Common.Accessory.FPSCounter.#ctor">
            <summary>
             Private constructor, use factory method "Instance()" instead. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.Common.Accessory.FPSCounter.HandleRenderEvent(System.Object,System.EventArgs)" -->
        <member name="M:Arction.Gauges.Common.Accessory.FPSCounter.GetFrequency">
            <summary>
             Freq. as ticks (value) per second.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Common.Accessory.FPSCounter.QueueLen">
            <summary>
             Length of the queue containing timestamps of the 
             frames to calc the avg framerate.
             Must be at least 10.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Arction.Gauges.GaugeSettings" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.GaugeSettings.c_DefaulStylesFilename" -->
        <member name="F:Arction.Gauges.GaugeSettings.c_ScaleStylesPath">
            <summary>
             Directoryname that holds the styles / scale themes.
            </summary>
        </member>
        <member name="F:Arction.Gauges.GaugeSettings.c_GaugeStylesPath">
            <summary>
             Directoryname that holds the gauge themes.
            </summary>
        </member>
        <member name="F:Arction.Gauges.GaugeSettings.c_StateManagersPath">
            <summary>
             Directoryname that holds the state managers. 
             The state managers are not defined on the objects themselves, as 
             they need to be defined in XAML, and the objects do not have 
             XAML definitions. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.GaugeSettings.c_TemplatesPath">
            <summary>
             Directoryname that holds the templates.
            </summary>
        </member>
        <member name="M:Arction.Gauges.GaugeSettings.#ctor">
            <summary>
             Preferably use the static interface. If an instance is required, 
             use Instance() factory method. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.GaugeSettings.m_Settings">
            <summary>
             The process-global settings class. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.GaugeSettings.GetDictionary(System.String)">
            <summary>
             Retrieves the defined resource dictionery
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.GaugeSettings.GetDefaultTemplate(System.Type)">
            <summary>
             Getter of the default template for the given type.
            </summary>
            <remarks>
             Loeds the default templates XAML, iterates through it's contents 
             untill it finds a ControlTemplate that has a matching TargetType 
             and returns that. 
            </remarks>
            <param name="type">Type to get the default template for.</param>
            <returns>Null if no template was found, valid template otherwise.</returns>
            \internal
            \bug Does not differentiate the subclasses by length of 
            inheritance path.
        </member>
        <member name="M:Arction.Gauges.GaugeSettings.GetStateManager(System.Type)">
            <summary>
             Gets the VisualStateManagers from XAML storage for the given 
             type, if such is defined. 
             NOT USED, no need for this aftera ll. 
            </summary>
            <remarks>
            <H4>Why is the XAML not defined with the objects?</H4>
            Because due to some original (and possibly misguided) design 
            descisions the controls are only in .cs, and no XAML is used. 
            There is no XAMl files with most of the objects, and thus no
            place to define the VisualStateManagers, that need to be defined 
            in XAML.
            And as it seems, the VisualStateManager information can be 
            set on code, so no need for this.
            </remarks>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.GaugeSettings.GetObjectFromDictionary``1(System.Windows.ResourceDictionary)">
            <summary>
             Extracts the first item of the Type type from the given 
             ResourceDictionary, or null if none found. 
            </summary>
            <remarks>
             Implemented as generic instead of using type parameter because 
             this way the called does not have to cast the object. 
            </remarks>
            <typeparam name="Type">Type to search form the given resourcedictionary</typeparam>
            <param name="rd"></param>
            <returns>First item of type Type in the given rd, or default(Type) if none found.</returns>
        </member>
        <member name="M:Arction.Gauges.GaugeSettings.GetStateManagerResFileName(System.Type)">
            <summary>
             Parses the types to file names, containing the VisualStateManager 
             definitions for the given type. 
            </summary>
            <remarks>
             <p>It's explained on GetStateManager documentation why we're not
             just defining the state managers with objects.</p>
             <p>Note that the type must match exactly</p>
            </remarks>
            <param name="type">Type to get the filename for.</param>
            <returns>Filename of the XAML file containing the visual state 
            manager for the requested type. Empty string if type has no 
            specified VisualStateManager</returns>
        </member>
        <member name="P:Arction.Gauges.GaugeSettings.AssemblyName">
            <summary>
             Determines the name of the main GaugeControl assembly for the 
             current architecture. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Accessory.ResHelper.FindResByKey(System.Windows.FrameworkElement,System.Object)">
            <summary>
             Searches the resources dictionaries of "this" object and it's parents 
             for the given key. Pretty much the same thing as FindResources does, 
             but also on Silverlight. 
            </summary>
            <param name="Key"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Borders.CBorderBase.Init">
            <summary>
            
            </summary>
            <remarks>
            
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Borders.CBorderBase.ContentCenter">
            <summary>
             Getter of the current determined content center point. 
             Usefull for layout operations, as the objects is most likely to be
             positioned based on the content center. 
            </summary>
            <remarks>
            As this is the local position of the content center, 
            As a vector it means one pointing from used areas (of DesiredSize)
            left-top corner to the content center. 
            </remarks>
        </member>
        <member name="F:Arction.Gauges.Borders.OffsetType.None">
            <summary>
            No offset is set by default. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Borders.OffsetType.Positive">
            <summary>
             The geometry is moved fully to the positive quadrant, 
             its outer geometry lt-corner touching the origo. 
             Note that thiss will cause autocompute of points afret earch 
             property setting. 
            </summary>
        </member>
        <member name="T:Arction.Gauges.Borders.CBorderGeoControl">
            <summary>
             Data storage element for CircleBorder geometry. 
            </summary>
            <remarks>
             Originally part of the CircleBorder element. 
             The idea is that this can deliver the geometry of the CircleBorder 
             for the actual elements that knows how to daraw it. 
            </remarks>
            \internal
            \todo Move the extended range used in scaling to member, and calculate when the actual angles change. 
            Shoul speed up things. 
        </member>
        <member name="M:Arction.Gauges.Borders.CBorderGeoControl.UpdateGeometry">
            <summary>
            
            
            </summary>
            <remarks>
            <h1>About internal arcs centerpoint calculation</h1>
            ... need to draw a picture, but...
            sin alpha = c/b => b = c/sin alpha, where
            c = m_CenterPadding
            b = radius of the internal arcs centerpoint (it's on arc of that radius)
            alpha = beta/2, beta = difference of the angles. 
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Borders.CBorderGeoControl.CalcArcRadForWidth(System.Double,Arction.Gauges.Geo.AngleRange,Arction.Gauges.Geo.AngleRange,System.Double,System.Double)">
            <summary>
             Calculates the maximum radius (actually the internal ArcRadius) of the border 
             geometry for the given width. 
            </summary>
            <remarks>
            It's with, as we can use the same calculations to calculate the height by 
            rotating the geometry (by incresing the given angles by half pi) and 
            giving the height as width.
            There would be a slight speed increase if we would internally determine both
            height and widht and return the radius of the smaller one, but the code 
            would be somewhat harder to understand. 
            </remarks>
            <param name="Width">Widht of the total available area</param>
            <param name="range">Angle range of the border to fit to the width.</param>
            <param name="BT">Border Thickness</param>
            <param name="AP">Adjacent Padding</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.Borders.CBorderGeoControl.UpdateOffset" -->
        <member name="F:Arction.Gauges.Borders.CBorderGeoControl.m_FullCircle">
            <summary>
             Determines if the current geometry is to be full or not. 
            </summary>
            <remarks>
            Determined on Geometry update. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Borders.CBorderGeoControl.Size">
            <summary>
             Setter of the BorderControls size. 
             One should preferably modify the the existing size, instead of 
             setting new one. 
            </summary>
            <remarks>
             Setting causes geometry update. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Borders.CBorderGeoControl.FullCircle">
            <summary>
             
            </summary>
        </member>
        <member name="T:Arction.Gauges.Borders.CBorderGeoInfo">
            <summary>
             
            </summary>
            \todo This actually might be better as class.
        </member>
        <member name="M:Arction.Gauges.Borders.CBorderGeoInfo.UpdateVals">
            <summary>
             Calculate common values for different GeoSide options. 
             Contains the FC-status determination and correction, and thus might modify the given 
             ContentRad value
            </summary>
        </member>
        <member name="M:Arction.Gauges.Borders.CBorderGeoInfo.GetPoints(Arction.Gauges.Borders.GeoSide)">
            <summary>
             Returns the geomtery points (CBorderGeoPoins) for the given 
             geometry part (GeoSide). 
            </summary>
            <remarks>
             The returned points are calculated on call if they have not been
             previously calculated. After first call with given Size parameter, 
             the calculated points are cached and furter queries happen on 
             constant time (O(1)) (Well the calculation is practically constant 
             time as well, just a lot longer constant time). 
            </remarks>
            <param name="Side"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Borders.CBorderGeoInfo.CalcBounds(System.Collections.Generic.List{Arction.Gauges.Geo.Vec},System.Windows.Rect@)">
            <summary>
            
            </summary>
            
            <remarks>
             
            </remarks>
            <param name="Points">
             Array of vectors. All verctors are assumed to be screencorrected. 
             (y-increases towards bottom). 
            </param>
            <param name="Bounds"></param>
            <returns></returns>
            
        </member>
        <member name="F:Arction.Gauges.Borders.CBorderGeoInfo.m_ContentRad">
            <summary>
             Radius of the arc, matches given ArcRad for the geometry.
            </summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CBorderGeoInfo.m_RoundBorder">
            <summary> If true, there is no straight parts in the arc. </summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CBorderGeoInfo.m_LegRad">
            <summary>
            Leg radius = geometry's legs length.
            Calculated, setting affects nothign. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CBorderGeoInfo.m_CCDist">
            <summary>
            ContentCenter distance (from center)
            Calculated, setting affects nothign. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CBorderGeoInfo.m_cdAPad">
            <summary>Distance from content center to inner edge center (Center Distance Ajacent Padding)</summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CBorderGeoInfo.m_cdHBT">
            <summary> Distance between geometry and edge centers (same for inner and outer - Center Distance Half Border Thickness)</summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CBorderGeoInfo.m_rdHBT">
            <summary> Radius (led distance) for HBT length. The other adjacent of triagle, where the other is m_cdHBT.</summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CBorderGeoInfo.m_StartUV">
            <summary> Start angle unit vector</summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CBorderGeoInfo.m_EndUV">
            <summary> End angle unit vector</summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CBorderGeoInfo.m_CUV">
            <summary> Center unit vector</summary>
        </member>
        <member name="P:Arction.Gauges.Borders.CBorderGeoInfo.RoundBorder">
            <summary>
            If true, there is no straight parts in the arc.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Arction.Gauges.Borders.CBorderGeoInfo.FullCircle" -->
        <member name="T:Arction.Gauges.Borders.CBorderGeoPoints">
            <summary>
            
            </summary>
        </member>
        <member name="P:Arction.Gauges.Borders.CBorderGeoPoints.Offset">
            <summary>
             Moves the geomety by the given offset. The Offset is 0,0 by default.
             Set offset can be queried using the getter. 
            </summary>
            <remarks> 
            Note that the offset does not affect the CBorderGeoInfo that created 
            this or other CBorderGeoPoints objects. 
            
            <para> 
            There is a posibility of "crawling", as we're modifying the offset
            by removing the old offset to get the org, value and then adding the 
            new offset. Doubles precision will cause in n generation noticaple 
            difference between the intended and the resulting value. 
            </para>
            </remarks>
            <param name="Offset"></param>
        </member>
        <member name="P:Arction.Gauges.Borders.CBorderGeoPoints.FullCircle">
            <summary>
             Determines if the geoemtrys start/end points are positioned so 
             that they should be connected, and the object ought to 
             form a full circle.
            </summary>
            <remarks>
             <p>Currently determined by comapring center-contenCenter distance 
             against ContentRadius</p>
            </remarks>
        </member>
        <member name="T:Arction.Gauges.Borders.CBorderLine">
            <summary>
             Draws border using simple path, with stroke and fill, from the provided 
             CBorderGeoInfo object
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Borders.CBorderLine.#ctor(Arction.Gauges.Borders.GeoSide,Arction.Gauges.Borders.CBorderGeoControl)">
            <summary>
             
            </summary>
            <param name="Side">Geometry to follow</param>
            <param name="Geo">The Geometry controller to use as data source</param>
        </member>
        <member name="M:Arction.Gauges.Borders.CBorderLine.MeasureOverride(System.Windows.Size)">
            <summary>
             
            </summary>
            <param name="availableSize"></param>
            <returns></returns>
            \pre UpdateGeometry has been run (unless on size scaling with null size)
        </member>
        <member name="M:Arction.Gauges.Borders.CBorderLine.ArrangeOverride(System.Windows.Size)">
            <summary>
            
            </summary>
            <remarks>
            The function assumes that given finalSize is the same as return from 
            measure as desiredsize. 
            </remarks>
            <param name="finalSize"></param>
            <returns></returns>
        </member>
        <member name="P:Arction.Gauges.Borders.CBorderLine.ContentCenter">
            <summary>
             Getter of the current determined content center point. 
             Usefull for layout operations, as the objects is most likely to be
             positioned based on the content center. 
            </summary>
            <remarks>
            As this is the local position of the content center, 
            As a vector it means one pointing from used areas (of DesiredSize)
            left-top corner to the content center. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Borders.CBorderLine.Path">
            <summary>
             Accessor to the intenral path. 
            </summary>
            <remarks>
             Use this to contro colors, etc. Note that the border is invisible if no colors are set. 
            </remarks>
        </member>
        <member name="T:Arction.Gauges.Borders.CBorderWF">
            <summary>
             Item that knows how to draw the CircleBorderGeo using filled 
             polygons
            </summary>
            <remarks>
             Originally part of CircleBorder, separated to support multiple drawing
             methods and to simplicy the actual CircleBorder object. 
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Borders.CBorderWF.MeasureOverride(System.Windows.Size)">
            <summary>
             
            </summary>
            <param name="availableSize"></param>
            <returns></returns>
            \pre UpdateGeometry has been run (unless on size scaling with null size)
        </member>
        <member name="M:Arction.Gauges.Borders.CBorderWF.ArrangeOverride(System.Windows.Size)">
            <summary>
            
            </summary>
            <remarks>
            The function assumes that given finalSize is the same as return from 
            measure as desiredsize. 
            </remarks>
            <param name="finalSize"></param>
            <returns></returns>
        </member>
        <member name="P:Arction.Gauges.Borders.CBorderWF.ContentCenter">
            <summary>
             Getter of the current determined content center point. 
             Usefull for layout operations, as the objects is most likely to be
             positioned based on the content center. 
            </summary>
            <remarks>
            As this is the local position of the content center, 
            As a vector it means one pointing from used areas (of DesiredSize)
            left-top corner to the content center. 
            </remarks>
        </member>
        <member name="T:Arction.Gauges.Borders.CircleBorder">
            <summary>
            
            </summary>
            \bug Setting geometry size at measure phase (if we have none) will cause HandleGeometryUpdate event 
            to launch and that will cause re-measurement, possible never ending loop if the size setting does 
            pre-check the given value. Also, we share the size, thus setting the geometrys size sets our own size...
        </member>
        <member name="P:Arction.Gauges.ICircularElement.ContentCenter">
            <summary>
             Centering position for the items contents. 
            </summary>
            <remarks>
            
            </remarks>
            \todo Document the meaning of the ContentCenter better. 
            \internal
            \par History. 
            Before this property, there was CenterToBoxLT property. 
            The meaning is quite the same, this is simply a vector (or point) 
            from objects LT-corner (it practically must be the origo, i think) 
            to the center of the contents. 
        </member>
        <member name="T:Arction.Gauges.Interfaces.ICopyable">
            <summary>
             Classes of ICopyable interface can construct a workable copy of itself. 
             The interface does NOT promise the copy to be shallow or deep, just
             that it works. 
            </summary>
            <remarks>
            The purpose of this interface is to provide promise of simple interface
            that allows users - mainly CopyConverter - to identify copyable objects 
            and to create copies of them. 
            
            Created mainly as there is no IClonable on SIlverlight, and we need 
            to be able to make copies of objects loaded from resources, as 
            in Silverlight those objects can't normally be used in UI. 
            </remarks>
        </member>
        <member name="F:Arction.Gauges.Borders.CircleBorder.ParentStateGroupName">
            <summary>
             Defines the state names used in the visual state group 
             "BorderParent" defining the parent item. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Borders.CircleBorder.HandleLightDirChange(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Event handler for the light direction changes
            </summary>
            <remarks>
            Bound to both local DP and to the parent Gauge element, if such is given. 
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.Borders.CircleBorder.HandleStrokeChanged(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Event handler for Strpke property changes. 
            </summary>
            <remarks>
             Assumes that the call comes after m_Stroke's value has changed.
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.Borders.CircleBorder.HandleFillChanged(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Event handler for fill property changes. 
            </summary>
            <remarks>
             Assumes that the call comes after m_Fill's value has changed.
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.Borders.CircleBorder.SetParentType(Arction.Gauges.Borders.CircleBorder.ParentType)">
            <summary>
             Controls the ParentType state
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:Arction.Gauges.Borders.CircleBorder.LightUpdate">
            <summary>
             Checks for light direction changes and handles the updates accordingly. 
             Assumes that something has changed and does always the updates, so dont 
             call for nought.
            </summary>
            \note Currently disabled, untill we know how to do this well enough. 
        </member>
        <member name="M:Arction.Gauges.Borders.CircleBorder.MeasureOverride(System.Windows.Size)">
            <summary>
             
            </summary>
            <param name="availableSize"></param>
            <returns></returns>
            \pre UpdateGeometry has been run (unless on size scaling with null size)
        </member>
        <member name="M:Arction.Gauges.Borders.CircleBorder.ArrangeOverride(System.Windows.Size)">
            <summary>
            
            </summary>
            <remarks>
            The function assumes that given finalSize is the same as return from 
            measure as desiredsize. 
            </remarks>
            <param name="finalSize"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.Borders.CircleBorder.FullCircleValueMapper" -->
        <member name="M:Arction.Gauges.Borders.CircleBorder.HandleGeometryUpdated(System.Object,System.EventArgs)">
            <summary>
            
            </summary>
            <remarks>
            We should come here for all changes in geometry, including setting of our own start/end angles. 
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
            \bug Causes measure invalidation also when it's not required. 
        </member>
        <member name="F:Arction.Gauges.Borders.CircleBorder.m_VisibleContentCenter">
            Temporary solution, we'll modify geometry drawing so that this is not required.. possibly 
        </member>
        <member name="F:Arction.Gauges.Borders.CircleBorder.m_SizeReq">
            Keeps the rect to arrange the path to. 
        </member>
        <member name="F:Arction.Gauges.Borders.CircleBorder.m_Range">
            <summary>
             Angle range of the the circleborder. 
             Might not be owned by us, but the parent. Should not be 
             modified by this class. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Borders.CircleBorder.m_MeasureCount" -->
        <member name="P:Arction.Gauges.Borders.CircleBorder.Area">
            <summary>
             information specifying the borders basic layout, meaning Start- 
             and AngleEnd's and the seep direction.
            </summary>
            <remarks>
             <para>Note that the AngleRange is usually shared by the borders 
             parent, and it's a class (ref-type), thus modification of the 
             returned object will result in modification of the parent objects
             properties. 
             </para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Borders.CircleBorder.LightDirection">
            <summary>
             Direction the light is shining from
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Borders.CircleBorder.AdjacentPadding">
            <summary>
             Offset (margin, padding) of the center of the circle. 
            </summary>
            <remarks>
            Also see ArcPadding. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Borders.CircleBorder.RoundBorder">
            <summary>
             Defines if the adjacent padding part of the arc is drawn as round 
             or as straight line. 
            </summary>
            <remarks>
            Pass through property of the CBorderGeoControl.RoundBorder
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Borders.CircleBorder.Gauge">
            <summary>
            The gauge this elements belongs to. 
            </summary>
            <remarks>
            Used for getting the proper generic settings. Might change leter to 
            GaugeControl or some more abstract interface, that would make is possible
            for the "High parent" (or "controller") to be some other class as well. 
            <para>Can be and set to null</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Borders.CircleBorder.Size">
            <summary>
             
            </summary>
            <remarks>
            If the given value is of RadialSizeInt type, reference to it will 
            be used, and the supported values set. 
            If null is given, a new size is initialized.
            If some other type of RadialSize is given, it'll be copied. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Borders.CircleBorder.ContentCenter">
            <summary>
             Getter of the current determined content center point
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Borders.CircleBorder.CenterToBoxLT">
            <summary>
             Returns a vector from center of the virtual circle to the left-top
             corner of the actual element/area to draw. 
             Together with the desired size this is to produce a valid 
             information for bounding box (rect) to be used at arrangement 
             and measurement pahses, by allowing the parent to position the 
             element based on the center point of the virtual circle.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Borders.CircleBorder.FullCircle">
            <summary>
             Controls m_FullCircle variable and visibility of full circle / partial circle elements
            </summary>
            <remarks>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Arction.Gauges.Borders.CircleBorder.MeasureCount" -->
        <member name="T:Arction.Gauges.Borders.CircleBorder.ParentType">
            <summary>
             Enum defining the current type of the parent. 
             see the internal SetParentType() method.
            </summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CircleBorder.ParentType.Undefined">
            <Summary>The default</Summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CircleBorder.ParentType.Gauge">
            <Summary>The default</Summary>
        </member>
        <member name="F:Arction.Gauges.Borders.CircleBorder.ParentType.Scale">
            <Summary>The default</Summary>
        </member>
        <member name="M:Arction.Gauges.Converters.AngleConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
             
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.AngleConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.AngleConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            </summary>
            
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.AngleConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
             
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="T:Arction.Gauges.Converters.RadToDegConverter">
            <summary>
             Radians to Degrees converter
            </summary>
        </member>
        <member name="T:Arction.Gauges.Converters.AngleUnitConverter">
            <summary>
             Converts doubles from angle unit to an other. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Converters.AngleUnitConverter.#ctor(Arction.Gauges.Converters.AngleType,Arction.Gauges.Converters.AngleType)">
            <summary>
             Base for different angle unit converters to use with bindings. 
            </summary>
            <remarks>
            Note that the convert and ConvertBack methods use object
            as the base type to move data, thus this cause value boxing when 
            used with primitive types, suchs as double, that is the only one
            currently supported. 
            </remarks>
            <param name="SrcType">Source angle unit to convert from.</param>
            <param name="DstType">Destination nagle unit to convert to.</param>
        </member>
        <member name="M:Arction.Gauges.Converters.AngleUnitConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
             Converts given double from defined source type to the destination type
            </summary>
            <param name="value">Value to convert as double</param>
            <param name="targetType">Type to produce, only double is supproted.</param>
            <param name="parameter">Ignored</param>
            <param name="culture">Ignored</param>
            <returns>Given value in destination angle units as double</returns>
        </member>
        <member name="M:Arction.Gauges.Converters.AngleUnitConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
             Converts given double from defined destination type to the source type
            </summary>
            <param name="value">Value (angle) to convert as double</param>
            <param name="targetType">Type to produce, only double is supproted.</param>
            <param name="parameter">Ignored</param>
            <param name="culture">Ignored</param>
            <returns>Given value in source angle units as double</returns>
        </member>
        <member name="T:Arction.Gauges.Converters.DegToRadConverter">
            <summary>
             Degrees to radians converter
            </summary>
        </member>
        <member name="T:Arction.Gauges.Converters.DoubleRadAngleConverter">
            <summary>
             Version of the DoubleAngleConverter that assumes the underlying double 
             to represent the angle in <i>radians</i>
            </summary>
        </member>
        <member name="M:Arction.Gauges.Converters.DoubleAngleConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
             
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.DoubleAngleConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.DoubleAngleConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
             Converts given type to angle (double) of AngleType, specified by Type property.
            </summary>
            <remarks>
             Currently this system expects values in string to contain angle in degrees.
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <returns></returns>
            \internal 
            \par Data flow
            When value is edited in propertyeditor, it seems that it comes here with string, and a double is produced 
            of \ref Type(). This is then called with that value, so we come here with values double of unit \ref Type, 
            not double/degrees as it would be expected. As a result, we need not do anything in here.
        </member>
        <member name="M:Arction.Gauges.Converters.DoubleAngleConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
             Converts angle (double) of AngleType specified by Type property to requested type.
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="P:Arction.Gauges.Converters.DoubleAngleConverter.Type">
            <summary>
             reports the type of the underlying angle unit.
            </summary>
            <param name="?"></param>
            <returns></returns>
        </member>
        <member name="T:Arction.Gauges.Converters.DoubleDegAngleConverter">
            <summary>
             Version of the DoubleAngleConverter that assumes the underlying double 
             to represent the angle in <i>radians</i>
            </summary>
        </member>
        <member name="M:Arction.Gauges.Converters.DialConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
             
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.DialConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.DialConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <returns></returns>
            \note Currently only a test setup. The string can be anythign, it'll allways result in the same Dial. 
        </member>
        <member name="M:Arction.Gauges.Converters.DialConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
             
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.RadialSizeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
             
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.RadialSizeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.RadialSizeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <returns></returns>
            \note Currently only a test setup. The string can be anythign, it'll allways result in the same Dial. 
        </member>
        <member name="M:Arction.Gauges.Converters.RadialSizeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
             
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.RadialSizeConverter.StringToSource(System.String,System.Boolean@)">
            Determines the type of the size definition by the string identifier. 
            \param Type String describing the content of the size string. 
            See page RadialSizeParsing for more infromation. 
            \param[out] Identified Determines if the given string was successfully identified or not. 
            \note Falls back to ScalingSource.Radius as a default scaling source. 
        </member>
        <member name="M:Arction.Gauges.Converters.RadPosConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
             
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.RadPosConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.RadPosConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <returns></returns>
            \note Currently only a test setup. The string can be anythign, it'll allways result in the same Dial. 
        </member>
        <member name="M:Arction.Gauges.Converters.RadPosConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
             
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="T:Arction.Gauges.Converters.RangeConverter">
            <summary>
             Version of the DoubleAngleConverter that assumes the underlying double 
             to represent the angle in <i>radians</i>
            </summary>
        </member>
        <member name="F:Arction.Gauges.Converters.RangeConverter.ConvCulture">
            <summary>
             Culture used in the string->double conversion.
            </summary>
        </member>
        <member name="M:Arction.Gauges.Converters.RangeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
             Determines the supported <i>source</i> types for conversion 
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.RangeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
             Determines the supported <i>target</i> types for conversion 
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.RangeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
             Converts given object to Range
            </summary>
            <remarks>
             <p>Range to Range conversion returns the original Range object's reference.</p>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <returns></returns>
            \bug Does not detect negative infinity properly 
        </member>
        <member name="M:Arction.Gauges.Converters.RangeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
             Converts Range to string to the requested destinatino type. 
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
             <p>If requested conversion to Range, the given object refrence is returned. </p>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="T:Arction.Gauges.Converters.SizeConverter">
            <summary>
             Basic converter between String and System.Windows.Size. 
            </summary>
            <remarks>
            <h2>Reason:</h2>
            <para>SizeConveter does not exist in Silverlight</para>
            <h2>Format:</h2>
            <para>Widht;Height.</para>
            <para>Values can use either . or , as decimal separator. 
            Value separator can be either ; or |.</para>
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Converters.SizeConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
             
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.SizeConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.SizeConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <returns></returns>
            \note Currently only a test setup. The string can be anythign, it'll allways result in the same Dial. 
        </member>
        <member name="M:Arction.Gauges.Converters.SizeConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
             
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.TextBlockConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
             
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="sourceType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.TextBlockConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
            
            </summary>
            <remarks>
            <para>TypeConverter calls this with null context if the other version is called.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Converters.TextBlockConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
            
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <returns></returns>
            \note Currently only a test setup. The string can be anythign, it'll allways result in the same Dial. 
        </member>
        <member name="M:Arction.Gauges.Converters.TextBlockConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <summary>
             
            </summary>
            <remarks>
             <para>Called internally by TypeConverter with current culture for Culture and null for context values.</para>
             <para>Context and cultuer parameters are ignored.</para>
            </remarks>
            <param name="context">Ignored</param>
            <param name="culture">Ignored</param>
            <param name="value"></param>
            <param name="destinationType"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.DProp.CDPManager`2.CaptureDP(System.String)">
            <summary>
             Creates now DP and binds it to the given dependencyproperty
            </summary>
            <param name="ExistingDP"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.DProp.CDPManager`2.nsCaptureCache(System.String,System.Windows.DependencyObject,System.EventHandler{Arction.DProp.DPChangedEventArgs})">
            <summary>
             Creates now DP (if not already created) and binds it to the given dependencyproperty.
             Exists so that we have simple way of detecting inherited dependencyproperty value changes in SL. 
            </summary>
            <remarks>
             See the Static version's documentation
            </remarks>
            <param name="Name"></param>
            <param name="Callback"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.DProp.CDPManager`2.CaptureCache(System.String,System.Windows.DependencyObject,System.EventHandler{Arction.DProp.DPChangedEventArgs})">
            <summary>
             Creates now DP (if not already created) and binds it to the given dependencyproperty.
             Exists so that we have simple way of detecting inherited dependencyproperty value changes in SL. 
            </summary>
            <remarks>
             The name of the created dependencyprperty is same as of the 
             original ones, appended wiht "Override"
            </remarks>
            <param name="ExistingDP"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.DProp.CDPManager`2.CreateCache(System.String,`1,System.EventHandler{Arction.DProp.DPChangedEventArgs})" -->
        <member name="M:Arction.DProp.CDPManager`2.nsCreateCache(System.Windows.DependencyProperty,System.EventHandler{Arction.DProp.DPChangedEventArgs})">
            <summary>
             Get existing or create new cache based on DP
            </summary>
            <param name="dp"></param>
            <param name="DefValue"></param>
            <param name="Callback"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.DProp.CDPManager`2.nsGetCache(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.EventHandler{Arction.DProp.DPChangedEventArgs})">
            <summary>
             Gets the cache object of the given owner/DP. Creates one if it does not exists already. 
             Calls the GetCache method with the proper OwnerType.
            </summary>
            <param name="Owner"></param>
            <param name="dp"></param>
            <param name="Callback"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.DProp.CDPManager`2.GetCache(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.EventHandler{Arction.DProp.DPChangedEventArgs})">
            <summary>
             Gets the cache object of the given owner/DP. Creates one if it does not exists already. 
            </summary>
            <remarks>
             <para>Note that the Callback property is set only if the cache object does not exist, and thus a new one
             is created.</para>
            </remarks>
            <param name="Owner"></param>
            <param name="dp"></param>
            <param name="Callback"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Arction.DProp.cDProp`2" -->
        <member name="T:Arction.DProp.IDPropBase">
            <summary>
             
            </summary>
            \todo Need to move this to i's own file. 
        </member>
        <member name="P:Arction.DProp.IDPropBase.Property">
            <summary>
             Getter of the internal DependencyProperty.
            </summary>
        </member>
        <member name="M:Arction.DProp.DPropBase.#ctor">
            <summary>
            Empty constructor, exist so that inheriting classes can 
            already call the base() constructor, in case we need to 
            do something here 
            </summary>
        </member>
        <member name="M:Arction.DProp.DPropBase.op_Implicit(Arction.DProp.DPropBase)~System.Windows.DependencyProperty">
            <summary>
            Converter operator to DependencyProperty. 
            Allows the DProp based classes to be used in place of the DependencyProperties. 
            </summary>
            <param name="Base">The DPropBase object to convert into DependencyObject</param>
            <returns></returns>
        </member>
        <member name="P:Arction.DProp.DPropBase.Property">
            <summary>
             Getter of the internal DependencyProperty.
            </summary>
        </member>
        <member name="P:Arction.DProp.IcDPropBase.OwnerObject">
            <summary>
             Getter of the owner as dependencyobject
            </summary>
        </member>
        <member name="M:Arction.DProp.cDProp`2.#ctor(System.String,`1,`0)">
            <summary>
             Main constructor for the cDProp. Requires default value. 
            </summary>
            <remarks>
            <h1>Thrown exceptions:</h1>
            The function calls DependencyProperty.Register(...) function. If the identical property has 
            already been registered, that function will throw an error. 
            </remarks>
            
            <param name="Owner">Owner of this property</param>
            <param name="PropName">Name of the property</param>
            <param name="DefValue">Default value of the property</param>
            [AttributeUsageAttribute(AttributeTargets.Parameter, Inherited = false)]
        </member>
        <member name="M:Arction.DProp.cDProp`2.Dispose(System.Boolean)">
            <summary>
             Disposes the object.
            </summary>
            <remarks>
            The implementation is not complete. The higher levels of the 
            structures are not clened up. We'd need ref-counting for that. 
            </remarks>
            <param name="RunFromDestructor"></param>
        </member>
        <member name="M:Arction.DProp.cDProp`2.SetOwner(`0)">
            <summary>
            Adds the given Owner as the owner of this object. 
            This allows the cDProp object to be static and the local elements to use the same object (sharign 
            the storage) and still receive personal callback updates. 
            .... Except it does not. Shold have no effect what so ever if the owner adds itself or not. All
            it needs is someone to add itself as the owner. 
            </summary>
            <param name="Owner"></param>
        </member>
        <member name="M:Arction.DProp.cDProp`2.Get">
            <summary>
             Getter of the cached value. Effectively identical to the Value propertys get part. 
            </summary>
            <returns>Currently cached value</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.DProp.cDProp`2.Set(`1)" -->
        <member name="M:Arction.DProp.cDProp`2.SetCache(`1)">
            <summary>
             Sets the internal cache, but does not update the generic dependecy value itself. 
             Call UpdateFromCache to move the cached value upwards. 
            </summary>
            <param name="value">Value to store to the cached member</param>
        </member>
        <member name="M:Arction.DProp.cDProp`2.UpdateFromCache">
            <summary>
             Updates the DependencyProperty storage from the cached value. 
             Causes the callback events to be launched. 
            </summary>
        </member>
        <member name="M:Arction.DProp.cDProp`2.GetProperty(System.String)">
            <summary>
             Tries to find the dependencyproeprty for the given name.
            </summary>
            <param name="Name"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.DProp.cDProp`2.onPropertyChange(System.Windows.DependencyObject,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
            Callback function detecting the chagnes in the dependencyproperty.
            </summary>
            <param name="d"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.DProp.cDProp`2.CacheUpdate(`1)">
            <summary>
             To be called when teh cache is to be updated from the DependencyObject storage
            </summary>
            <param name="value">
            The new value of the object. 
            </param>
        </member>
        <member name="E:Arction.DProp.cDProp`2.ValueChangedEvent">
            <summary>
            Event that is called when the higher level value has changed. This event is not emitted 
            if the local cache value changes. 
            </summary>
        </member>
        <member name="P:Arction.DProp.cDProp`2.Property">
            <summary>
             Getter of the internal DependencyProperty
            </summary>
        </member>
        <member name="P:Arction.DProp.cDProp`2.Value">
            <summary>
            Cached value accessor
            </summary>
            <remarks>
            <H1>On set:</H1>
            Updates the internal cache and the generic storage. 
            <H1>On get:</H1>
            Returns the cached value
            
            <h1>Problems</h1>
            If the cDProb is static (no point there) the we need to set multiple items. 
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Arction.DProp.SourceType.Setter" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.DProp.SourceType.DP" -->
        <member name="M:Arction.DProp.DPCacheBase.#ctor(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.String)">
            <summary>
            
            </summary>
            <remarks>
            </remarks>
            <param name="Owner"></param>
            <param name="dp"></param>
            <param name="PropertyName"></param>
        </member>
        <member name="M:Arction.DProp.DPCacheBase.BindFrom(System.Windows.DependencyObject,System.String,System.Boolean)">
            <summary>
             Binds the dependencyproperty to the given destination.
            </summary>
            <param name="Source"></param>
            <param name="PropertyName">Name of the source property. If not set this propertys name is used.</param>
            <param name="TwoWay"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.DProp.DPCacheBase.BindTo(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.Boolean,System.Windows.Data.IValueConverter)">
            <summary>
             Binds the dependencyproperty to the given destination.
            </summary>
        </member>
        <member name="F:Arction.DProp.DPCacheBase.m_CacheDiffers">
            <summary>
             Indicates if the cache and DP are currently synced or not. 
            </summary>
        </member>
        <member name="F:Arction.DProp.DPCacheBase.m_DefaultValue">
            <summary>
             Default value of the dependencyvalue. Set on DetermineValueSource method call.
            </summary>
        </member>
        <member name="M:Arction.DProp.DPCache`1.SetOwner(System.Windows.DependencyObject,System.EventHandler{Arction.DProp.DPChangedEventArgs})">
            <summary>
             Sets the owner and internal callback at the same time. 
             Setting callback at this point does not have to be static.
            </summary>
        </member>
        <member name="M:Arction.DProp.DPCache`1.NotifInternalsOfValueChange">
            <summary>
             Calls the owner's callback function reporting that the value has 
             changed. A fake report, intended to go around the default value 
             problems
            </summary>
        </member>
        <member name="M:Arction.DProp.DPCache`1.SetCurrentValue(`0,System.Boolean,Arction.DProp.SourceType)">
            <summary>
             Cross "platform" implementation of the WPF's 
             DependencyObject.SetCurrentValue method, that does not affect 
             BaseValueSource (and thus does not mess the value precedence. 
            </summary>
            <param name="value">Value to set to the current cache AND 
            DP without chaing the reported source of the value. 
            </param>
            <param name="InternalNotification">Deteremines if the internal listeners 
            should be notified of the change</param>
            <param name="SType">Source type of the data. Defaults to SourceType.Setter.
            Mainly intended for keeping of the current source type. 
            </param>
        </member>
        <member name="M:Arction.DProp.DPCache`1.UpdateDP(System.Boolean)">
            <summary>
             Updates the DependencyProperty from cache, if it differs, and notifies
             the external listeners of the change.
            </summary>
            <remarks>
             <para>Use Force proeprty to skip the equality checks to make update slightly faster.</para>
             <para>Note that the methods does nothing on Silverlight, as it's 
             missing DependencyProperty.SetCurrentValue method. </para>
            </remarks>
            <param name="Force">If true, skips the equality checks and just updates the DP.</param>
        </member>
        <member name="M:Arction.DProp.DPCache`1.Set(`0)">
            <summary>
             Setst he value, notifies everyone, including owner. 
            </summary>
            <Remarks>
            Intended to be called from setters, that we wish to get notification ourselves as well.
            Third fastest (slowest) update option
            </Remarks>
            <param name="Value"></param>
        </member>
        <member name="F:Arction.DProp.DPCache`1.m_FirstChange">
            <summary>
             Keeps track if the cache object has yet been used to deliver 
             any changse. 
             The first change skips similarity/change checks and 
             notify listeners of the change even if there has been no real 
             change.
            </summary>
        </member>
        <member name="P:Arction.DProp.DPCache`1.v">
            <summary>
             Direct setters of the internal, without any notifications to anyone
             The fastest way of setting the value
            </summary>
        </member>
        <member name="P:Arction.DProp.DPCache`1.Value">
            <summary>
             Notifies external users of the change, meaning both dependency property (and bouded values) and external 
             listeners. 
             Kind of the second fastest option
            </summary>
        </member>
        <member name="P:Arction.DProp.DPCache`1.Cache">
            <summary>
             Identical to c property
            </summary>
        </member>
        <member name="T:Arction.DProp.DPropCapsule">
            <summary>
            Simple capsuler for DependencyProperties. Allows on to use DPropBase on normal 
            DependencyProperties. This exists mainly for testing, at least for now. 
            </summary>
        </member>
        <member name="P:Arction.DProp.DPropCapsule.Property">
            <summary>
             Getter of the internal DependencyProperty
            </summary>
        </member>
        <member name="T:Arction.DProp.DPropConverter">
            <summary>
            Converter test for the cachin dynamic property placeholder thing, so that it would seem as a real DynamicProperty object. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.DProp.DPWatcher.Bind(System.Windows.DependencyObject,System.Windows.DependencyProperty,System.String,System.EventHandler)">
            <summary>
             
            </summary>
            <remarks>
             Yes, it's quite stupid to request all src, prop., and PropName, as the Property object ought to know all of those. 
             It might, but in SL there seems not to be any way of getteing them out of the thing. 
            </remarks>
            <param name="Src"></param>
            <param name="Property"></param>
            <param name="PropertyName"></param>
            <param name="Callback"></param>
        </member>
        <member name="T:Arction.Gauges.Extensions.DependencyPropertyExtensions">
            <summary>
            Extension methods for DependencyProperty class. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Extensions.Extensions.RadToFirstPosCycle(System.Double)">
            <summary>
             Converts the input angle in radians to the first full positive 
             circle.
            </summary>
            <remarks>
             There might be similar methods elsewhere as well. 
            </remarks>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.Extensions.SafeAdd(System.Windows.Size,System.Windows.Point)">
            <summary>
            Adds the given value to both dimensions of size. 
            This version is guaranteed to produce valie Size, meaning that the values will not go to negative side.
            </summary>
            <param name="src"></param>
            <param name="Value"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.Extensions.Substract(System.Windows.Size,System.Double)">
            <summary>
             Substracts given value from both of the sizes components. 
            </summary>
            <remarks>
            Note that the function can not produce negative sizes, as the size structure does not allow it. 
            
            </remarks>
            <param name="src"></param>
            <param name="Value"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.Extensions.CanHold(System.Windows.Size,System.Windows.Size)">
            <summary>
             Determines if the "Smaller" size is smaller in both directions compared to the
             "Bigger" size. 
            </summary>
        </member>
        <member name="T:Arction.Gauges.Extensions.FrameworkElementExtensions">
            <summary>
            Extension methods for FrameworkElement class. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Extensions.FrameworkElementExtensions.InvalidateParentMeasure(System.Windows.FrameworkElement,System.Boolean)">
            <summary>
            Same as UIElement's InvalidateMeasure (calls it) but by default
            also invalidates the panels parents measurement. 
            </summary>
            <param name="Raising">Determines if the panels parent's measurement 
            should be invalidated as well.</param>
            <returns>True if the parent was UIElement and its InvalidateMeasure got called.</returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.FrameworkElementExtensions.InvalidateParentArrange(System.Windows.FrameworkElement,System.Boolean)">
            <summary>
             Invalidates parent objects arrange, is parent is UIElement.
            </summary>
            <param name="src"></param>
            <returns>True if the parent was UIElement and its InvalidateArranges got called.</returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.GridExtensions.AddCol(System.Windows.Controls.Grid,System.Windows.GridLength)">
            <summary>
             Creates a new column with given size for the grid.
            </summary>
            <param name="grid"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.GridExtensions.Insert(System.Windows.Controls.Grid,System.Windows.FrameworkElement,System.Int32,System.Int32)">
            <summary>
             Inserts the given item at the given row and column. 
            </summary>
            <remarks>The row and column must exist</remarks>
            <param name="grid"></param>
            <param name="item"></param>
            <param name="row"></param>
            <param name="column"></param>
        </member>
        <member name="M:Arction.Gauges.Extensions.GridExtensions.Insert(System.Windows.Controls.Grid,System.Windows.FrameworkElement,System.Int32)">
            <summary>
             Inserts the given item at the given column at a NEW row.
            </summary>
            <param name="grid"></param>
            <param name="item"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.GridExtensions.AddRow(System.Windows.Controls.Grid)">
            <summary>
             Adds a new row to the grid and returns it's index
            </summary>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.GridExtensions.AddRow(System.Windows.Controls.Grid,System.Windows.Controls.RowDefinition@)">
            <summary>
             Adds a new row to the grid and returns it's index
            </summary>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.GridExtensions.AddRow(System.Windows.Controls.Grid,System.Windows.GridLength)">
            <summary>
             Adds a new row to the grid and returns it's index
            </summary>
            <returns></returns>
        </member>
        <member name="T:Arction.Gauges.Extensions.IListExtensions">
            <summary>
             Extension methods for classes that implement IList interface
            </summary>
        </member>
        <member name="M:Arction.Gauges.Extensions.IListExtensions.InsertEnd(System.Collections.IList,System.Int32,System.Object)">
            <summary>
             Inserts item by counting the index from the end. 
            </summary>
            
            <param name="list">List to insert the item</param>
            <param name="Index">Index to insert the item, calculated fromt the end.
            Values 0 or less (negative values) result to insertion to the last of the list, 
            Positive values cause insertion counting form the end of the list. 
            1 results the item to be the second last item in the list, 
            list size and larger values results on the item to be the first item of the list.</param>
            <returns>True if the insertion was a success. Captures 
            \li ArgumentOutOfRangeException and
            \li NotSupportedException
            exceptions</returns>
            \todo Maby change to internal and set libs as friends
        </member>
        <member name="M:Arction.Gauges.Extensions.IListExtensions.AddItems(System.Collections.IList,System.Object[])">
            <summary>
             Insert items from the given array to the list. 
            </summary>
            <remarks>
            Implemented mainly to ease up fast implementation of debugging elements, not
            for any real or fast work. 
            </remarks>
            <param name="list"></param>
            <param name="Objects"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.IListExtensions.InsertRelative(System.Collections.IList,System.Object,System.Object,System.Int32)">
            <summary>
             Insert item to list relative to position of some other element.
             Used by InsertAfter and InsertBefore functions. 
            </summary>
            <remarks>
             Currently this function has not protection of checnking given values, or checking if the resulting index 
             is valid
            </remarks>
            <param name="list"></param>
            <param name="ex">Existing item. If null, insertion happends using add function = to the end of list.
            </param>
            <param name="ni">New item to insert. No internal checks, list itself should throw error if null.</param>
            <param name="id">Index difference. Value to add to the found ex items index for Insert function.</param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.LinearGradientBrushExtensions.SetAngle(System.Windows.Media.Brush,System.Double,System.Windows.Size)">
            <summary>
             Calculates the Start and end points of the LinearGradientBrus object to match the 
             given angle. 
             
            Overridden version, converts given size ot aspect ratio.
            </summary>
            
            <param name="brush"></param>
            <param name="Angle"></param>
            <param name="size"></param>
        </member>
        <member name="M:Arction.Gauges.Extensions.LinearGradientBrushExtensions.SetAngle(System.Windows.Media.LinearGradientBrush,System.Double,System.Windows.Size)">
            <summary>
             Calculates the Start and end points of the LinearGradientBrus object to match the 
             given angle. 
             
            Overridden version, converts given size ot aspect ratio.
            </summary>
            
            <param name="brush"></param>
            <param name="Angle"></param>
            <param name="size"></param>
        </member>
        <member name="M:Arction.Gauges.Extensions.LinearGradientBrushExtensions.SetAngle(System.Windows.Media.LinearGradientBrush,System.Double,System.Double,System.Boolean)">
            <summary>
             Calculates the Start and end points of the LinearGradientBrus object to match the 
             given angle. 
            </summary>
            <param name="brush"></param>
            <param name="Angle"></param>
            <param name="Aspect">
             Aspect ratio of the area to set the ange for, defaults to 1. 
             Calculated by width/height, meaning that values unser 1 are wide.
            </param>
        </member>
        <member name="M:Arction.Gauges.Extensions.PointCollectionExtension.AddItems(System.Windows.Media.PointCollection,System.Windows.Point[])">
            <summary>
             Insert points from the given array to the list. 
            </summary>
            <remarks>
            Implemented mainly to ease up fast implementation of debugging elements, not
            for any real or fast work. 
            </remarks>
            <param name="list"></param>
            <param name="Objects"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.RectExtensions.Moved(System.Windows.Rect,System.Windows.Point)">
            <summary>
             Creates new rect that has been offset by the given vector. 
             Created to replace the Rect.Offset method that is not 
             implemented in SL.
            </summary>
            <param name="r"></param>
            <param name="vec"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.RectExtensions.MoveToOrigo(System.Windows.Rect)">
            <summary>
             Moves the rect so that if the original rect contains some geometry, 
             that geometrys left-top corner will be at origo. 
             Will affect the size as well. 
            </summary>
            <remarks> 
             this function exist mainly for the ArrangeOverride methods needs. 
             No all of the graphics exist on positive quadrant, or close to the
             origo, and this arranges them so that they will. 
             
             <para>The following is obsolete, the size is allways modified. </para>
             <para>Size will be modified if the resulting rect goes to negative 
             side, as the original size would otherwise cause clipping. On
             the other direction clipping does not occure, but we simply use 
             too much space... this might be good to fix as well. </para>
            </remarks>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.RectExtensions.ltc(System.Windows.Rect)">
            <summary>
             Returns the coordinates (as vecotor) to the rects left-top corner. 
             Matches the TopLeft property of the rect, that is available on WFP. 
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.RectExtensions.GetSize(System.Windows.Rect)">
            <summary>
             Named as getter, so that one would not mistake this for a property Size,
             that only the WPF implementaion has. 
            </summary>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.SweepDirExtensions.Factor(System.Windows.Media.SweepDirection)">
            <summary>
             Produces a coefficient (multiplier) that presents the direction in 
             normal polar coordinates. 
             In effect, -1 for clockwise and 1 for counterclockwise.
            </summary>
            <param name="?"></param>
            <returns></returns>
        </member>
        <member name="T:Arction.Gauges.Extensions.ThicknessExtensions">
            <summary>
            Extension methods for FrameworkElement class. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Extensions.ThicknessExtensions.LT(System.Windows.Thickness)">
            <summary>
             Forms vecto from source thickness where x coordinate is 
             thickness' left property and y is top. 
            </summary>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Extensions.ThicknessExtensions.IsEmpty(System.Windows.Thickness)">
            <summary>
             Test if the given thickness is null all-around.
            </summary>
            <param name="src">The source thickness object to test emptines of.</param>
            <returns>True if all of the sides of thickness are 0, false otherwise.</returns>
        </member>
        <member name="M:Arction.Gauges.Geo.aMath.CSymSize(System.Double)">
            <summary>
             Creates new symmetrica size with given diameter. 
            </summary>
            <param name="Diameter"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.aMath.FitsIn(System.Windows.Size,System.Windows.Size)">
            <summary>
             Checks if the a fits inside b. 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.aMath.CenterRect(System.Windows.Size,System.Windows.Size)">
            <summary>
             the Item is centered inside the Area parameter. 
             Forms rect with size of Item parameter, with top-left point so that
            </summary>
            <remarks>
            The Area ought to be larger than the Item. If not, 
            rect of smaller 0.0 / smaller proportions is returned. 
            </remarks>
            <param name="Area">The available size</param>
            <param name="Item">Size of the item to center inside the area.</param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.aMath.CenterRect(System.Windows.Point,System.Windows.Size)">
            <summary>
             Creates new rect, with given size and centered at the given points
            </summary>
            <param name="CenterPoint"></param>
            <param name="Area"></param>
        </member>
        <member name="M:Arction.Gauges.Geo.aMath.AngleToPosRound(System.Double)">
            <summary>
             ValueMappers the given angel (in rads) to the positive side angles, 
             ignoring but the last round. 
             The resultin value is betweeh 0 and 2*pi. 
             Just uses ArcGeometryControl.Norm, one ought to just use it directly.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.aMath.LineIntersection(System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Windows.Point,System.Windows.Point@)">
            <summary>
            Calculates intersection point of two lines. Line 1: goes through A1 and A2
            Line 2: goes through B1 and B2
            Algorithm copied from http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/
            </summary>
            <param name="a1">Line A point 1</param>
            <param name="a2">Line A point 2</param>
            <param name="b1">Line B point 1</param>
            <param name="b2">Line B point 2</param>
            <param name="intersection">intersection point output</param>
            <returns>Success status. Returns false if could not solve the intersection</returns>
            \internal
            Copied originally from v6.x Charts ChartTools.LineIntersection
        </member>
        <member name="T:Arction.Gauges.Geo.Angle">
            <summary>
             Presents information of an angle and offers some helper functions for that. 
             Not actually caring what the angle is relative to, but certain function 
             assume its against normal polar coordinate 0-angle.
            </summary>
        </member>
        <member name="M:Arction.Gauges.Geo.Angle.#ctor(System.Double)">
            <summary>
            
            </summary>
            <param name="value">Angle in radians</param>
        </member>
        <member name="M:Arction.Gauges.Geo.Angle.FromPoints(System.Windows.Point,System.Windows.Point,System.Boolean)">
            <summary>
             Generates an angle form the given points. 
             The angle is initialized from radians.
            </summary>
            <param name="Start"></param>
            <param name="End"></param>
            <param name="ScreenCorrect"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.Angle.FromPoints(Arction.Gauges.Geo.VecS,Arction.Gauges.Geo.VecS)">
            <summary>
             Generates an angle form the given points. 
             The angle is initialized from radians.
            </summary>
            <param name="Start"></param>
            <param name="End"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.Angle.Diff(System.Double,System.Double,System.Windows.Media.SweepDirection)">
            <summary>
             Calculated the angle difference between the given start and end angles, currently reducing it to one round. 
            </summary>
            <remarks>
            Usefull for instance on determining if the angle is large or small. 
            Not as easy as one would think..
            </remarks>
            <param name="AngleStart"></param>
            <param name="AngleEnd"></param>
            <param name="SweepDir"></param>
            <returns></returns>
        </member>
        <member name="P:Arction.Gauges.Geo.Angle.Value">
            <summary>
             Value of the angle in given units (currently radians, might change).
            </summary>
        </member>
        <member name="T:Arction.Gauges.Geo.Range">
            <summary>
             Class specifying a range as Start- and Endpoint of doubles.
            </summary>
            <remarks>
            
            </remarks>
            \internal
            \par Inheritance
            Inherits DependencyObject only because it's required for the VisualStudio designer property editor, 
            as it does not know how to create new object otherwise, it seems. 
        </member>
        <member name="M:Arction.Gauges.Geo.Range.OnRangeChanged">
            <summary>
             Function to send event notifying of range change. 
            </summary>
            <param name="args"></param>
            \internal
            Tested this way of doing this. Taking the args object directly, we can init it first on the caller, then 
            chane the value and then just emit the signal. This way we dont have to make an extra temp var at the 
            sender side. 
            On a second thought, the whole argument is somewhat unimportnant, and we get to send only one message when
            both are updated. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.Geo.Range.InRange(System.Double)" -->
        <member name="M:Arction.Gauges.Geo.Range.InRange(System.Double,System.Double)">
            <summary>
             Determines if the given value is in the range. 
             Both endpoints are included in the range. 
            </summary>
            <remarks>
            <p> When comparing caluclated values against set limits, the end 
            point handling can be slightly erratic. For this reason a Variance 
            parameter can be given, that allows user to increase / decrease the
            range by given amount for the comparison. </p>
            <p> Not yet implemented on AngleRange, so do not use there. </p>
            </remarks>
            <param name="Value"></param>
            <param name="Variance">Variance to allow the endpoints to slip.</param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.Range.ResetSmallerLarger">
            <summary>
             Resets both m_Smaller and m_Larger to null. 
             Needs to be run after either Start or End is updated. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.Geo.Range.InRange(System.Double,Arction.Gauges.Geo.EndPointIncl)" -->
        <member name="P:Arction.Gauges.Geo.Range.DirFactor">
            <summary>
             Determines if the start is larger or smaller than the end. 
            </summary>
        </member>
        <member name="T:Arction.Gauges.Geo.Range.DirFactors">
            <summary>
             Specifies whether the start is lareger than end or other way around. 
             Unset value indicates that the value has not yet been calculated. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Geo.AngleRange.InRange(System.Double)">
            <summary>
            </summary>
            <param name="Value"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.AngleRange.ConvToOneRound">
            <summary>
            Converts currently defined range so that they are on one round, between angles -360..360 and 
            in proper direction in correlation to the sweep direction 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Geo.AngleRange.StrokeEdge(System.Double,System.Boolean)">
            <summary>
             Calculates the vector to the edge of the two connecting lines
             (represented here by just their angles) if their strokewidth would be 
             the given value.
            </summary>
            <remarks>
             This is quite a bad and counter intuitive place for this code to live at. 
             <P>Not tested</P>
            </remarks>
            <param name="StrokeThickness"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.AngleRange.Extend(System.Double,System.Boolean)">
            <summary>
             Extendes the angle range from both ends by the given angle. 
             One can use negative angle to reduce the angle range. 
            </summary>
            <remarks>
            <para>The resulting angle is extended by full circle if 
            the resulting angles will be the same. </para>
            </remarks>
            <param name="Angle">Angle to extend the area from both ends.</param>
            <param name="AllowOverlap">If true, the resulting angles are allowed 
            to overlap and in effect resulting to a much smaller angle than the 
            orignal. If false (default) the angle change is limited to 
            half of the distance between start and stop angles.</param>
        </member>
        <member name="M:Arction.Gauges.Geo.AngleRange.AngleInRange(System.Double,System.Double,System.Double,System.Windows.Media.SweepDirection)">
            <summary>
            Determines if the given value is at the given range. 
            </summary>
            <remarks>
            Note that the given range must be valid / sensible, meaning the start and end values can not be 
            in the wrong order. 
            Current implementation is quite slow, but seems to work. 
            </remarks>
            <param name="Value"></param>
            <param name="Start"></param>
            <param name="End"></param>
            <param name="Dir"></param>
            <returns></returns>
        </member>
        <member name="P:Arction.Gauges.Geo.AngleRange.Length">
            <summary>
            
            </summary>
            \internal 
            \todo Make sure we're not doing anythign too slugish here
            \todo We should store the full circle count + overhead on here as well, as
            those are required elsewhere. 
        </member>
        <member name="P:Arction.Gauges.Geo.AngleRange.FullCircle">
            <summary>
             Determines if the angle range forms excactly full circle. 
             If the range defines over 360 degrees area, it's not necessarilly 
             FullCircle, in terms of this method. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Geo.AngleRange.CenterAngle">
            <summary>
             <para>Returns the "center angle", that is the angle in between the 
             start and end angles, going to the ranges direction from the 
             start angle. </para>
             If the range defines a full-circle (start and end angles are the 
             same), the returned angle is the opposite angle, which is also the
             center angle, but traversing from the start to the opposite 
             direction.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Geo.AngleRange.DirFactor">
            <summary>
             Determines if the start is larger or smaller than the end, 
             taking the sweep direction into an account.
            </summary>
        </member>
        <member name="T:Arction.Gauges.Geo.DegAngleRange">
            <summary>
             Just for debug, should be removed from the final and/or release build
            </summary>
        </member>
        <member name="T:Arction.Gauges.Geo.GeoOffsetType">
            <summary>
             Defines possible offset types for the \ref ArcGeometryControl class.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="F:Arction.Gauges.Geo.GeoOffsetType.None">
            <summary>
             No offset. Same as defining manual withot setting the offset. 
             In effect the arc is thus centered in origo.
            </summary>
        </member>
        <member name="F:Arction.Gauges.Geo.GeoOffsetType.Manual">
            <summary>
             Manually defined static offset. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Geo.GeoOffsetType.Radius" -->
        <member name="T:Arction.Gauges.Geo.ArcGeometryControl">
             <summary>
              Geometry drop-in replacement that Defines (calculates) an arc geometry from two angles, sweep direction and radius. 
             </summary>
             <remarks>
              The implicit Geometry converter makes it possible to use this as a geometry with Path object. 
             
              Angles are defined as radians. 
              aMath has easy to use degree->rad converter ToRads(). 
              
              \par Positioning 
              Positioning of the produced geometry can be controlled using \ref OffsetType and 
              \ref ManualOffset properties. 
              
              \par Usage in Gauges. 
              This class is used by \ref PrimaryScale component together with Path class to draw  
              the arc line for the PrimaryScale. At that uses all of the properties are controlled by 
              the PrimaryScale. 
            
             </remarks>
             \todo Add direct access to the AngleRange.
        </member>
        <member name="M:Arction.Gauges.Geo.ArcGeometryControl.#ctor">
            <summary>
             Default constructor
            </summary>
        </member>
        <member name="M:Arction.Gauges.Geo.ArcGeometryControl.op_Implicit(Arction.Gauges.Geo.ArcGeometryControl)~System.Windows.Media.Geometry">
            <summary>
             Convert this object to to geometry object
            </summary>
            \note The returned value is reference to the internal object, that will be updated as this 
            object is modified. 
            <param name="src">Valid ArcGeometryControl object</param>
            <returns>Reference to the internal PathGeometry object.</returns>
        </member>
        <member name="M:Arction.Gauges.Geo.ArcGeometryControl.UpdateGeometry">
            <summary>
             Re-calculates arc geometry. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Geo.ArcGeometryControl.InitGeometry">
            <summary>
             Initializes the internal geometry objects. 
             \sa m_Fig, m_Geo, m_Seg
            </summary>
        </member>
        <member name="F:Arction.Gauges.Geo.ArcGeometryControl.m_ArcSeg">
            <summary>
            The segment defining the arc, only segment of the \ref m_Fig
            </summary>
        </member>
        <member name="F:Arction.Gauges.Geo.ArcGeometryControl.m_ArcSeg2">
            <summary>
            The segment defining the half of the arc when the geometry forms 
            full circle. Part of the figure only when start and end 
            angles are the same. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Geo.ArcGeometryControl.m_Fig">
            <summary>
            The figure containing \ref m_Seg, only child of \ref m_Geo
            </summary>
        </member>
        <member name="F:Arction.Gauges.Geo.ArcGeometryControl.m_Geo">
            <summary>
            The geometry holding \ref m_Geo. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Geo.ArcGeometryControl.m_Range">
            Range defining angles and sweep direction. Controller through 3 different properties.
        </member>
        <member name="F:Arction.Gauges.Geo.ArcGeometryControl.m_Radius">
            Radius of the arc, controlled by \ref Radius property
        </member>
        <member name="F:Arction.Gauges.Geo.ArcGeometryControl.m_OffsetType">
            \brief Type of the offset to use on geometry positioning. 
            Only affects position of the points. See \ref GeoOffsetType for information of the 
            possible options. Controlled by \ref OffsetType property.
            Defaults to None. 
        </member>
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Geo.ArcGeometryControl.m_FullCircleSpacing" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Geo.ArcGeometryControl.m_AutoUpdate" -->
        <member name="F:Arction.Gauges.Geo.ArcGeometryControl.m_InFullValueMapperMode">
            <Status>
             Holds the full-circle / arc status of the current figure. 
             In other words, tells if the m_ArcSeg2 is currently part of the 
             m_Fig.
            </Status>
        </member>
        <member name="F:Arction.Gauges.Geo.ArcGeometryControl.m_ContentCenter">
            <summary>Cached Content center. </summary> 
             Accessable using \ref ContentCenter property.
             Calculated at \ref GeometryUpdate 
        </member>
        <member name="P:Arction.Gauges.Geo.ArcGeometryControl.Geometry">
            <summary>
             Secondary getter of the actual geometry. Uses the converter operator.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Geo.ArcGeometryControl.Radius">
            <summary>Radius of the ArcGeometryControl.</summary>
            Intended to be used by parent, not set directly unless element is used by itself.
            Set protected agains setting old value. When value changes, causes geometry to be updated. 
            
            \internal
            Controls \ref m_Radius member. 
            Respects \ref m_AutoUpdate.
            \sa UpdateGeometry()
        </member>
        <member name="P:Arction.Gauges.Geo.ArcGeometryControl.Range">
            <summary>
             Base Layout of the Arc, meaning Starting and Ending angles, and the sweep direction.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Geo.ArcGeometryControl.ManualOffset">
            <summary>
             Manual offset. 
             Setting this automatically adds GeoOffsetType.Manual to the OffsetType. 
            </summary>
            
            \internal
            Controls \ref m_Offset member. 
            Respects \ref m_AutoUpdate.
        </member>
        <member name="P:Arction.Gauges.Geo.ArcGeometryControl.OffsetType">
            <summary>Offset type of the arc. Controls how to position the arc geometry.</summary>
            Different options are explained on \ref GeoOffsetType documentation. 
            
            \internal
            Controls \ref m_OffsetType member. 
            Respects \ref m_AutoUpdate.
        </member>
        <member name="P:Arction.Gauges.Geo.ArcGeometryControl.AutoUpdateGeometry">
            <summary>
             Defines if the modification of layout settings should cause automatic
             re-calulation of geometry. 
            </summary>
            This exist so that multiple settings can be set without doing geometry 
            calculations on every setting for nothign. 
            
            \internal
            Controls \ref m_AutoUpdate member. 
            Causes geometry recalculation (\ref UpdateGeometry) if setting to true. 
        </member>
        <member name="P:Arction.Gauges.Geo.ArcGeometryControl.FullCircleSpacing">
            <summary>
             Determines if the arc geometry is positioned as if part of a full circle or if it's positioned so 
             that it takes as litle space as possible. 
            </summary>
            
            <remarks>
            If true, the center of the circle is always at point r,r (+ possible Manul offset), and
            the end/start points of the arc at the perimeter of the virtual circle. 
            This has the effect that when drawn using path, the path will not take just 
            the space required by the line, but of the virtual circle as well, where left on the 
            top-left side of the actual arc. 
            
            Setting this to false, the endpoints (when possible) moved to the PrimaryScale lines, thus reducing the 
            extra space requirement.
            This can be done also manually, as the data for this is available through Geometry.BoundingBox 
            property. 
            
            As the Path or Geometry does not upport negative points, the center is at r,r, not at origo. 
            To move it back to origo, one can just offset the points. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Geo.ArcGeometryControl.ContentCenter">
             \name Layout parameter getters
            @{
            
             <summary>
              Getter of the coordinates (as vector from lt-corner) of the content 
              center. It is at the same time the center of the virtual circle. 
             </summary>
             \internal 
             in effect returns \ref m_ContenCenter members value. 
        </member>
        <member name="T:Arction.Gauges.Geo.LineSeg">
            <summary>
             Simple line data container, mainly holds two points (vectors). 
            </summary>
            <remarks>
             <para>The name is not "Line", as system namespace already has object 
            of that name, and this is quite probably used at same places as that one. 
            The "Line Segment" is technically a more precise term, as Line has no 
            end points.
            </para>
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Geo.LineSeg.#ctor(System.Double,System.Double)">
            <summary>
             positive line-segment constructor. 
             The line is fully on the positive quadrant of the value-space.
            </summary>
            <param name="Angle"></param>
            <param name="Length"></param>
        </member>
        <member name="M:Arction.Gauges.Geo.LineSeg.Center(System.Windows.Size)">
            <summary>
             Re-positions the line's center to the center of the give area. 
             Length of the line does not change. 
            </summary>
            <param name="Area"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.LineSeg.Norm(System.Windows.Size)">
            <summary>
             Normalize the line so that the coordinates are in [0.1] space.
             The opration needs the assumed area of space they now live in.
            </summary>
            <remarks>
             Modifies and returns this object. 
            </remarks>
            <returns></returns>
        </member>
        <member name="P:Arction.Gauges.Geo.LineSeg.Length">
            <summary>
             Calculates or sets the length of the line. 
             Setting lenght will cause only the endpoint to move. 
            </summary>
            <remarks>
             One can easily implement the moving of the start point by 
             first storing the origina end point, and then adding the difference
             of the old and new start point to both points.
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ScalingSource.ContentRadius" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ScalingSource.Radius" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ScalingSource.InnerRadius" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ScalingSource.OuterRadius" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ScalingSource.Size" -->
        <member name="T:Arction.Gauges.SizeChangeEventArgs">
            <summary>
            
            </summary>
            \par Supported properties
            The owner of the object defines what properties it supports, as on setting one value the owner must be able to 
            convert into other properties, and thus not all of them are allways supported. 
            \par 
            Setting an unsupported value causes an ArgumentException to be thrown.
            Readin the value does not indicate in any way that it's unsupported, except by returnin the default value of the 
            given type (currently double). 
            \par 
            Read and write support of specific properties can be checked using \ref CanSet(), \ref CanGet() functions, or 
            \ref GetSupported and \ref SetSupported properties. 
        </member>
        <member name="T:Arction.Gauges.RadialSize">
            <summary>
             Capsules size information for a radial components. 
             Note that this class does NOT offer any calculations of the relation 
             between the different properties, but just holds the variables. 
            </summary>
            <remarks>
            
            </remarks>
            \todo Add separate events for scalign type changes and size chagnes, possibly containing information of what 
            property has changed and how. This is partly unnecessary, as each property supports it's own event notification
            \todo Add update control system, so that user can (if so wished) just update these values and notify of the 
            chagnes in one patch.
        </member>
        <member name="M:Arction.Gauges.RadialSize.onValueChanged">
            \bug The content radius type does not change if the dependencyproperty is set through some 
            other method. This code could be on the change handler, but it's not clear if it would get called 
            on internal calls as well, after determinatio of contentradius
        </member>
        <member name="M:Arction.Gauges.RadialSize.Set(Arction.Gauges.RadialSize)">
            <summary>
             Does a deep copy of object, without actually creating new object. 
            </summary>
            <param name="src"></param>
            \par Inheriting
            When inheriting RadialSize, remember to call this, as part of the fields (private ones) need to be set here. 
        </member>
        <member name="M:Arction.Gauges.RadialSize.ToString">
             Types and enums 
            @}
        </member>
        <member name="M:Arction.Gauges.RadialSize.CanSet(Arction.Gauges.ScalingSource)">
            Tests if the given ScalingSource can be set.
            \return true if \b all of the given ScalingSources can be set. 
        </member>
        <member name="M:Arction.Gauges.RadialSize.CanGet(Arction.Gauges.ScalingSource)">
            Tests if the given ScalingSource can be read.
            \return true if \b all of the given ScalingSources can be read.
        </member>
        <member name="M:Arction.Gauges.RadialSize.IsSupportedSource(Arction.Gauges.ScalingSource)">
            Tests if the given ScalingSource can be read and set
            \return true if \b all of the given ScalingSources can be set and read. 
        </member>
        <member name="M:Arction.Gauges.RadialSize.CheckCanGet(Arction.Gauges.ScalingSource)">
            Throws an exception if reading the given scaling source is not supported
        </member>
        <member name="F:Arction.Gauges.RadialSize.m_Changes">
            Pending changes that have not yet bee notified listeners of. 
        </member>
        <member name="F:Arction.Gauges.RadialSize.d_ConversionMsg">
             Private fields
            @}
        </member>
        <member name="P:Arction.Gauges.RadialSize.Radius">
            <summary>
             radius of the elements geometry. Usually will cause the element to take symmetrical sphere of space, 
             no matter the angles.
            </summary>
        </member>
        <member name="P:Arction.Gauges.RadialSize.InnerRadius">
            <summary>
             Inner radius of the element. Setting will usually cause the element to take 
             symmetrical sphere of space, no matter the angles.
            </summary>
            <remarks>
             Most objects do not support this yet, quite similar to the Content Radius
            </remarks>
        </member>
        <member name="P:Arction.Gauges.RadialSize.OuterRadius">
            <summary>
             Outer radius of the element, will usually cause the element to 
             take symmetrical sphere of space, no matter the angles.
            </summary>
        </member>
        <member name="P:Arction.Gauges.RadialSize.ContentRadius">
            <summary>
             Radius available for the content
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Arction.Gauges.RadialSize.Size" -->
        <member name="P:Arction.Gauges.RadialSize.AutoValueMapper">
            <summary>
            
            </summary>
        </member>
        <member name="P:Arction.Gauges.RadialSize.ScalingType">
            <summary>
             Sets / Gets the way the border ValueMappers. 
             This is automatically set on proper property setting.
            </summary>
        </member>
        <member name="P:Arction.Gauges.RadialSize.SettableSources">
            <summary>
            Defines the ScalingSources that setting of this size object supports. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.RadialSize.GettableSources">
            <summary>
            Defines the ScalingSources that reading of this size object supports. 
            \todo Set ungettable values to NaN or mark them unsupported somehow
            </summary>
        </member>
        <member name="M:Arction.Gauges.RadialSizeInt.#ctor(Arction.Gauges.ScalingSource)">
             \name Construction and initialization
            @{
            
        </member>
        <member name="M:Arction.Gauges.RadialSizeInt.Set(Arction.Gauges.RadialSize)">
            <summary>
             Allows deep copy of object, without actually creating new object. 
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:Arction.Gauges.RadialSizeInt.HandleRadiusChanged(System.Object,Arction.DProp.DPChangedEventArgs)">
            @{
        </member>
        <member name="P:Arction.Gauges.RadialSizeInt.Radius">
            <summary>
             Length from the center of content to the middle of the line. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.RadialSizeInt.InnerRadius">
            <summary>
             Length from the center of the content to the inner edge of the line. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.RadialSizeInt.OuterRadius">
            <summary>
             Length from the center of the content to the outer edge of the line. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.RadialSizeInt.ContentRadius">
            <summary>
             Length from the center of the content to the end of the area reserved for content. Difference to the Inner radius is 
             that this takes the ArcPadding into account. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.RadialSizeInt.Size">
            <summary>
             Size of the lines outer edge bounding box.
            </summary>
        </member>
        <member name="P:Arction.Gauges.RadialSizeInt.AutoValueMapper">
            <summary>
             Determines if the size should be autodetemined by given size on 
             measure phase. Sets ScalingType to Size, but does not cause 
             change notifications. 
            </summary>
            <remarks>
             this is quite ugly way of doing this. The Size should be the 
             place to define this kind of functionality, but as it's used
             at places that do not have measure phase, it's not really correct
             either. 
             Secondly, the vertical and horizontal alignment properties ought 
             to detemine this. 
             <p>To emphasize, if this is true, the owner of the size object 
             is responsible - or at least allowed - to set the size property, and 
             thus possibly move the scaling type back to size. If this is 
             not the intention, autoValueMapper ought to be set to false.</p>
            </remarks>
        </member>
        <member name="T:Arction.Gauges.Geo.RadPosType">
            <summary>
             Distance types of the RadPosS structures and RadPos class' Distance 
             field. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Geo.RadPosType.Factor">
            <summary> The distance is factor (a percentual value scaled to 
            [0,1] range) of the full possible length. The full length 
            is dependant on the point of use. </summary>
        </member>
        <member name="F:Arction.Gauges.Geo.RadPosType.Absolute">
            <summary>
             Distance is an absolute value, in virtual pixels. The 
             actual physical pixel count of one virtual pixes varis from 
             platform to an other. In Silverlight they match the physical 
             pixels. 
            </summary>
        </member>
        <member name="T:Arction.Gauges.Geo.RadPosS">
            <summary>
             Structure holding information that descripes a poin in radial 
             coordinates, as an angle and distance from the center. 
             Used especially with free-floating gauge elements, like titles and 
             value indicators, to position them in the gauge. 
            </summary>
            <remarks>
            <para>RadPos is a class that boxes this structure to a ref-type.</para>
            <para>0 angle is toward right</para>
            </remarks>
        </member>
        <member name="F:Arction.Gauges.Geo.RadPosS.Distance">
            <summary>
             Distance of the point from the center. Unit is dependant on the 
             value of Type-field.
            </summary>
        </member>
        <member name="F:Arction.Gauges.Geo.RadPosS.Type">
            <summary>
             Type of the Distance-field. 
             See RadPosType for possible values and their meaning. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Geo.RadPosS.Angle">
            <summary>
             Angle of the point. 0 Angle is towards right. 
             Values are currently in radians.
            </summary>
        </member>
        <member name="T:Arction.Gauges.Geo.RadPosProp">
            <summary>
             Enum identifying RadPos classes properties. Used for change notifications
            </summary>
        </member>
        <member name="T:Arction.Gauges.Geo.RadPos">
            <summary>
             Presentation of a position in a polar coordinates, as an angle and distance from the center.
            </summary>
            <remarks>
             <p>Keeps the values on a single RadPosS structure, that is the same object through-out the lifetime of this 
             object, thus one can somewhat safely take the reference of the structure. Note however, that modifying the 
             structures values through the reference is not recommended, as those change will not cause any notifications</p>
             <p>Created for label positioning on gauges.</p>
            </remarks>
            \internal
            \bug Can not be set using Prop. Editor as not DependencyClass and has no own editor defined. 
        </member>
        <member name="M:Arction.Gauges.Geo.RadPos.GetVector(System.Double)">
            <summary>
             Getter of the position as vector, from the center of an imaginary circle. 
             Note that the circles radius needs to be given if the distance type is factor (not absolute). 
            </summary>
            <param name="Rad">
             Radius of the imaginary circle, used in calculating the absolute value from the stored factor. 
             Only used if the type is RadPosType.Factor.
            </param>
            <returns></returns>
        </member>
        <member name="E:Arction.Gauges.Geo.RadPos.ValueChanged">
            <summary>
             Notifies that some of the values has changed somehow.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Geo.RadPos.value">
            <summary>
             The actual data structure this class represents. 
            </summary>
            \internal 
            Changed to internal, for the designer thing otherwise puts this to 
            XAML as the value differes from the default value, and 
            as there is no string->RadPosS conversion, it's faulty 
            XAML. There should be no other reason to allow usage of this.
        </member>
        <member name="T:Arction.Gauges.Geo.EndPointIncl">
            <summary>
             Describes if the endpoints belong to the area or not. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Geo.EndPointIncl.None">
            <summary> Neither of the endpoints belong to the area.</summary>
        </member>
        <member name="F:Arction.Gauges.Geo.EndPointIncl.Start">
            <summary> Start belongs to the area, end does not.</summary>
        </member>
        <member name="F:Arction.Gauges.Geo.EndPointIncl.End">
            <summary> End belongs to the area, Start does not.</summary>
        </member>
        <member name="F:Arction.Gauges.Geo.EndPointIncl.Both">
            <summary> Both of the endpoints belong to the.</summary>
        </member>
        <member name="T:Arction.Gauges.Geo.VecS">
            <summary>
             Internal structure of the vec
            </summary>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.#ctor(System.Double,System.Boolean)">
            <summary>
             Constructs a new vector of length 1 from the given angle. 
            </summary>
            <param name="Angle">Angle of the vector in radians</param>
            <param name="ScreenCorrected">Screen correction status. If true, y grows down (is negated).</param>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.#ctor(System.Windows.Point,System.Windows.Point)">
            <summary>
             Vector between two points
            </summary>
            <param name="Angle"></param>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.AreaCenter(System.Windows.Size)">
            <summary>
             Constructs a vector from the areas lt-corner to the center of it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.AreaScCenter(System.Windows.Size)">
            <summary>
             Constructs a vector from the areas lt-corner to the center of it.
             The returned value is screen-corrected, thus the Y PrimaryScale grows to down direction. 
             Effectively same as LBtoC method. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.LBtoC(System.Windows.Size)">
            <summary>
             Constructs a vector from the areas rl-corner to the center of it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.RectIntersection(System.Windows.Rect,System.Boolean,Arction.Gauges.Geo.VecS@)">
            <summary>
            Calculates closest intersection of vector (origo originating) and a rectangles edge. 
            </summary>
            <remarks>
             Uses the static version internally. 
            </remarks>
            <param name="Av">Origo based vector to calculate the intersection for</param>
            <param name="Box">Rect defining the rectangle to find closest intersetion with. </param>
            <param name="Closest">Defines if we're looking for the farthest or the closest intersection.</param>
            <param name="intersection">intersection point output</param>
            <returns>Success status. Returns false if could not solve the intersection</returns>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.RectIntersection(Arction.Gauges.Geo.VecS,System.Windows.Rect,System.Boolean,Arction.Gauges.Geo.VecS@)">
            <summary>
            Calculates closest intersection of vector (origo originating) and a rectangles edge. 
            </summary>
            <remarks>
             Uses aMath.LineIntersection internally.
            </remarks>
            <param name="Av">Origo based vector to calculate the intersection for</param>
            <param name="Box">Rect defining the rectangle to find closest intersetion with. </param>
            <param name="Closest">Defines if we're looking for the farthest or the closest intersection.</param>
            <param name="intersection">intersection point output</param>
            <returns>Success status. Returns false if could not solve the intersection</returns>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.SymPoints(System.Double)">
            <summary>
             Forms new VecS with identical x and y parameters. 
            </summary>
            <param name="Point"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.CumPointList(Arction.Gauges.Geo.VecS[])">
            <summary>
             Creates a cumulative coordinate point list from a set fo vectors
            </summary>
            <remarks>
            The generated list starts from the first item. Null list is returned for null input.
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.op_Multiply(Arction.Gauges.Geo.VecS,Arction.Gauges.Geo.VecS)">
            <summary>
             Dot product of vectors. 
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.Perpendicular(System.Windows.Media.SweepDirection,System.Boolean)">
            <summary>
             Returns the perpendicular of the source vector. Original vector is not modified.
             Uses angle based construction and is thus slow. 
            </summary>
            <remarks>
            Might not be the fastest or the most precise way of doing this, but should work.
            </remarks>
            <param name="Sweep"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.Perpendicular2(System.Boolean)">
            <summary>
             Second implementation of the Perpendicualr method, that uses vector arithmetic and is much faster. 
            </summary>
            <remarks> 
            To get the "other" perpndicular vector, just multiply this with -1.</remarks>
            <param name="Sweep"></param>
            <param name="ScreenCorrect"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.Norm(System.Windows.Size)">
            <summary>
            Normalize the vector position to values in range [0,1] (length max = sqrt(2)).
            </summary>
            <remarks>
            <para>Modifies the structure.</para>
            </remarks>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.Max(System.Double)">
            <summary>
             Limits both dimensions separately from below. 
             (sets the minumum value ... yes highly counter intuative name, but
             think it as max of given value and current value).
            </summary>
            <remarks>
            <para>Means the same as running Max for both of the dimensions separately</para>
            <para>Modifies this object and returns a copy of itself.</para>
            </remarks>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Geo.VecS.ToPosMover">
            <summary>
             Creates a vector that moves (when summed) this vector so that 
             the line of the vector (length matters) is totally on positive side. 
            </summary>
            <remarks>
            Pretty much the same as PosEndpoint, but the main idea is slightly different. 
            This does not modify this vector, just produces an other one. 
            </remarks>
            <returns></returns>
        </member>
        <member name="F:Arction.Gauges.Geo.VecS.NullVec">
            <summary>
             Vector that has both of it's components as 0. 
             Default constructor creates identical item, and might be faster
             (as using this will in effect create new item as well). 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Geo.VecS.Angle">
            <summary>
             returns the angle of the given vector in radians
            </summary>
        </member>
        <member name="T:Arction.Gauges.Geo.Vec">
            <summary>
             Vector, meaning 2D matrix. 
             Pretty much identical to System.Windows.Vector, except works also on 
             Silverlight.
            </summary>
            <remarks>
            Capsules Point and offers some helper methods. 
            Note that this is class instead of struct, but might later be, as there might be a requiremet to create and
            dispence these quickly. If leaves as class, will implmenet IDIsposable
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Geo.Vec.#ctor(Arction.Gauges.Geo.Vec)">
            <summary>
             
            </summary>
            
            <param name="src"></param>
            \todo Implement shallow copy, might save a bit of memory.
        </member>
        <member name="M:Arction.Gauges.Geo.Vec.#ctor(System.Windows.Size)">
            <summary>
             Constructs the vector from size, meaning that the size's width and 
             height are considered as x and y coordinates, effectively forming 
             vector from areas (defined by the given size) top-left corner to the
             bottom-right corner. 
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:Arction.Gauges.Geo.Vec.#ctor(System.Double,System.Boolean)">
            <summary>
             Forms vector fromt a given angle. 
            </summary>
            <param name="Angle"></param>
        </member>
        <member name="M:Arction.Gauges.Geo.Vec.ScreenCorrect">
            <summary>
             ScreenCorrect, Same as InverseY function
            </summary>
        </member>
        <member name="T:Arction.Gauges.Gradients.LGP">
            <summary>
             Linear Gradient Point
            </summary>
        </member>
        <member name="M:Arction.Gauges.Gradients.LGP.#ctor(System.Double,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
             Creates a LGP point. 
            </summary>
            <remarks>
             Note that parameter order is not argb but rgba, and negative alpha values map to 255. 
            </remarks>
            <param name="o"></param>
            <param name="r"></param>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
        </member>
        <member name="T:Arction.Gauges.Interfaces.ICleaning">
            <summary>
             Interface for own cleaning and dispose methods. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Interfaces.ICleaning.Unsubscribe">
            <summary>
             kind of a Dispose method, that one ought to call to disengage it 
             from ValueMapper and other set references, so that it does not keep 
             references to any handled objects, and thus prevents this object
             to keep the references objects alive. 
            </summary>
            <remarks>
             <p>The original/main reason for this function is the listener 
             patterns side effect of keeping the listener alive longer 
             than it would be necessary, as the signal sender has reference 
             to this object.</p>
             <p>There would be 2 ways of normally handling this problem. 
             <ul>
                <li>Implementing IDisposable and calling Dispose when the 
                object is no longer used. </li> 
                <li>Using weak listerener pattern. </li>
             </ul>
             <p>The documentation clearly stats that the IDisposable is ONLY
             for unmanaged resources, and should not be used for handling 
             managed resources. Other sources state that it would break the 
             pattern. </p>
             <p>The second option is not available out-of-the-box for 
             SilverLight.</p>
             </p>
             <p>As neither of the obvious options are available, an own 
             interface is created. The object that has Unsubscribe called 
             ought to be still usable, but it has not events bound to it 
             (no references to it). It might be easier to init totally new 
             object that to reinstate such object to functionality. 
             </p>
            </remarks>
        </member>
        <member name="T:Arction.Gauges.Layout.LayoutInfo">
            <summary>
             Position iformation structure for RadialPanel
            </summary>
            <remarks>
            Eiter removed or totally rewritten. The current impl. is just to get things started. 
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Layout.LayoutInfo.CalcMeasRect(System.Windows.Size)">
            <summary>
             Calculates the desired arrangement rect for the given objects.
            </summary>
            <param name="DesiredSize"></param>
            <returns></returns>
        </member>
        <member name="F:Arction.Gauges.Layout.LayoutInfo.MeasRect">
            <summary>Rect calculated in measurement phase, to be used in arrangement. </summary>
        </member>
        <member name="P:Arction.Gauges.Layout.LayoutInfo.Size">
            <summary>Overridden size to use in arrange phase. </summary>
            <remarks>
            Note that if size is not set (is empty) the desired size of the 
            element is used as a base, and increased by the inverted negative
            side of the offset. This is because the negative side of the 
            element is not seen on DesiredSize, bure required to be 
            aknowledged in the arrange to prevent clipping. </remarks>
        </member>
        <member name="P:Arction.Gauges.Layout.LayoutInfo.Offset">
            <Summary>Offset to use in positioning of the element. </Summary>
        </member>
        <member name="T:Arction.Gauges.Layout.RadialPanel">
            <summary> 
             Panel that handles layout for elements in polar coordinates. 
            </summary>
            <remarks>
             Currently (at first stage) the panel will be quite dumm one. Childs 
             will have defined offset, and they must be able to produce their 
             required / wished sizes. 
             At measurement they will be given the space 
             left of the space given for this element after reducing it with the 
             offset. 
             As it is, that has nothing to do with polar coordinates and in effect its 
             actually quite identical to the action of Canvas. 
            
             At first the offsets are defined through setter. Later we might offer 
             attached property for that as well. 
            
             Later this is to change, so that one of the childs determines the size, 
             and it's used to determine the sizes of the rest of the objects. 
             
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Layout.RadialPanel.MeasureOverride(System.Windows.Size)">
            <summary>
             Measures the childs. 
             Position or the set layout size of the childs are NOT taken into 
             account, just desired sizes. 
            </summary>
            \internal
            \todo Implemnet system that takes the layoutinformation into 
            account, possibly a property to determine if it's used. 
            The desired sizes could be quickly taken into account by
            keeping track of the largest combined size and using that as 
            minimum size. 
        </member>
        <member name="M:Arction.Gauges.Layout.RadialPanel.ArrangeOverride(System.Windows.Size)">
            <summary>
             Arranges the childs of this panel on the order they are returned 
             from the underlying childs property with foreach. 
            </summary>
            <remarks>
            <para>The position used on arrange defaults to (0,0), unless an offset is 
            defined in the layoutinfo, in which case </para>
            <para>The space given for each child is at least it's desired size. If the 
            item is set to be laid out on the negative side, the size of the area on the 
            negative side is added to the desired size. </para>
            </remarks>
            <param name="finalSize"></param>
            <returns></returns>
            \todo Add flag that determines if the size expansion is to be used. 
        </member>
        <member name="M:Arction.Gauges.Layout.RadialPanel.Add(System.Windows.UIElement)">
            <summary>
             a Passthrough method for Children.Add method. 
            </summary>
            <remarks>
             Exists so that one can replace the internal panel base class 
             with this object. 
            </remarks>
            <param name="value"></param>
        </member>
        <member name="M:Arction.Gauges.Layout.RadialPanel.RemoveChild(System.Windows.UIElement)">
            <summary>
             Removes given child and it's layout information. 
             Preferably use this instead of the Children.Remove, as this 
             removes the layout information as well. 
            </summary>
            <param name="Child"></param>
        </member>
        <member name="M:Arction.Gauges.Layout.RadialPanel.Info(System.Windows.UIElement)">
            \name Dev stage code 
            These functions need to be remvoed / replaced. They are here only for the development, untill 
            something better is implemented. 
        </member>
        <member name="M:Arction.Gauges.Layout.RadialPanel.RemoveLayoutInfo(System.Windows.UIElement)">
            Removes the given childs layout information. 
            This ought to be run in case some UI element is to be deleted and/or
            removed from the childs list. 
        </member>
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Layout.RadialPanel.m_ArrangeCount" -->
        <member name="F:Arction.Gauges.Layout.RadialPanel.m_ForceMeasure">
            <Summary>If true, all childs must be re-measured - measure forced to invalid before measurement call.
            Intended as debugging tool. </Summary>
        </member>
        <member name="F:Arction.Gauges.Layout.RadialPanel.m_ForceArrange">
            <Summary>If true, all childs must be re-arranged - arrange forced to invalid before measurement call. 
            Intended as debugging tool. </Summary>
        </member>
        <member name="F:Arction.Gauges.Layout.RadialPanel.m_MoveToOrigo">
            <status>The system offsets all of the items (by same amount) so that all of the contens are fully in the 
            positive quadrant.</status>                                        
        </member>
        <member name="P:Arction.Gauges.Layout.RadialPanel.MeasureCount">
             \name Status infromation getters
            @{
        </member>
        <member name="P:Arction.Gauges.Layout.RadialPanel.ForceMeasure">
            <summary>
             Allows forcing the measurement of the childs by invalidating the 
             chids measurement just before calling the meausre method.
             NOT to be used on final product, intended for debugging purposes.
            </summary>
        </member>
        <member name="T:Arction.Gauges.Dials.IDial">
            <summary>
             Not really used yet, started on doing, but not updated, thus the interface needs to be separeted from the
             actual poitner later on, possibly having separete RadialDial and Dial interfaces.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Dials.SizeType.Factor" -->
        <member name="F:Arction.Gauges.Dials.DialShape.DefaultNeedle">
            <summary>
             Special case of needle to indicate to use the default option. 
            </summary>
            <remarks>
             The actual shape used is some of the other options, and can vary
             between releases.
            </remarks>
        </member>
        <member name="F:Arction.Gauges.Dials.DialShape.DullNeedle">
            <summary>
             A line-kind needle with dull end. The thicknes slightly decreases 
             over the lenth. 
            </summary>
            <remarks>
            Both start and end point's thickness can be modified through 
            method interface.
            </remarks>
        </member>
        <member name="F:Arction.Gauges.Dials.DialShape.Line">
            <summary>
             Static widht line. Extremely simple.
            </summary>
        </member>
        <member name="F:Arction.Gauges.Dials.DialShape.WideNeedle">
            <summary>
             A rounded, multilayer and highly customizable needle.
            </summary>
            <remarks>
             Customization does have only method interface, no editor 
             friendly properties. 
            </remarks>
        </member>
        <member name="F:Arction.Gauges.Dials.DialShape.SimpleCompassNeedle">
            <summary>
             Simple comapass needle consisting of two triangles.
            </summary>
        </member>
        <member name="F:Arction.Gauges.Dials.DialShape.None">
            <summary>
            No graphical needle. 
            </summary>
            <remarks>
            Note that this option does not prevent the system from using the
            Dial's tic to point to the value, it just removes the graphical 
            needle element. 
            </remarks>
        </member>
        <member name="F:Arction.Gauges.Dials.DialShape.Custom">
            <summary>
             value given in DialElement is used. 
            </summary>
        </member>
        <member name="T:Arction.Needles.IColoredNeedle">
            <summary>
             Interfeace for needle shapes that have customizable colors
            </summary>
            <remarks>
            </remarks>
            \internal
            \todo List based accessor for the colors etc, as that way we could 
            enable modification of the Needle on property editor. 
        </member>
        <member name="M:Arction.Needles.IColoredNeedle.GetColor(System.Int32)">
            <summary>
             Getter of a color
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Needles.IColoredNeedle.GetColorName(System.Int32)">
            <summary>
             Getter of a colors name / Description
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Needles.IColoredNeedle.SetColor(System.Int32,System.Windows.Media.Color)">
            <summary>
            Setter of a color.
            </summary>
            <param name="i"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="P:Arction.Needles.IColoredNeedle.ColorCount">
            <summary>
             Returs the number of customizable colors. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Dials.Dial.#ctor">
            <summary>
            
            
            </summary>
            <remarks>
            The Dial still gets it's size on measure round. If the absolute size is set, the Dial is ValueMapperd so 
            the final size is the requested size. If the factor is set, the Dial is ValueMapperd so that it's length is 
            ValueMapperd by the given factor, 100% (value 1.0) being half of the smaller of the dimensions given for
            MeasureOverride. 
            
            The original size of the Dial is needed for the scaling calculations. The desired sizes width is used
            as the original DialElements length, and height as width. 
            
            The measure round will always report null-size, no matter the sizing options. This might change later. 
            Setting the Length or LengthFactor does not invalidate arrange, as the length modification is done on 
            rendering phase by the RenderTransformation and does not affect the measure or arrange phases. 
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Dials.Dial.Dispose(System.Boolean)">
            <summary>
             Own protected abstract dispose function. 
             Implement on all required hierarchy levels, called by (hopefully 
             at some levels) public dispose function and at each level by 
             destructor.... 
             
            remember to call the base classes dispose.
            </summary>
            <param name="RunFromDestructor"></param>
        </member>
        <member name="F:Arction.Gauges.Dials.Dial.m_DialElement">
            <summary>
            
            </summary>
            <remarks>
            Note: Use SetDial method to set this.
            </remarks>
        </member>
        <member name="F:Arction.Gauges.Dials.Dial.m_ShapeBasedElement">
            <summary>
             Indicates if the m_DialElement is created because of call to 
             DialShape property setter. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Dials.Dial.m_ValueMapper">
            <summary>
             ValueMapper of the parent PrimaryScale, or dummy direct linear ValueMapper if no PrimaryScale is yet defined. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Dials.Dial.GetColor(System.Int32)">
            <summary>
             Getter of a color
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Dials.Dial.GetColorName(System.Int32)">
            <summary>
             Getter of a colors name / Description
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Dials.Dial.SetColor(System.Int32,System.Windows.Media.Color)">
            <summary>
            Setter of a color.
            </summary>
            <param name="i"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Dials.Dial.MeasureOverride(System.Windows.Size)">
            <summary>
             
            </summary>
            <remarks>
            Giving this element smaller size than the Dial element naturally is, will 
            result in clipping. Size given in this function can not be reliably be used to 
            ValueMapper the Dial. 
            </remarks>
            <param name="availableSize"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Dials.Dial.ArrangeOverride(System.Windows.Size)">
            <summary>
             Arranges the child elements. 
            </summary>
            <remarks>
             Function assumes the given finalSize will be the real final size reported by the parent at the 
             arrangeOverride function. 
            </remarks>
            <param name="finalSize"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Dials.Dial.UpdateAngle(System.Boolean)">
            <summary>
             Causes Dial and poiter marker position/angle changes according to the 
             current value of Angle property. 
            </summary>
            <remarks>
             If SetAngle is true, the angle is first set from Value property. 
             Note that Value property is never set from here. 
            </remarks>
            <param name="SetAngleFromValue">
             if true, the angle is first set from Value property. 
            </param>
        </member>
        <member name="M:Arction.Gauges.Dials.Dial.SetDial(Arction.Gauges.Dials.DialShape)">
            <summary>
             Sets Center and  DialElement based on the enum value.
            </summary>
            <param name="ps"></param>
        </member>
        <member name="M:Arction.Gauges.Dials.Dial.SetDial(System.Windows.FrameworkElement)">
            <summary>
             Handles the initializations and connections that ought to be done when modifyin m_DialElemnet. Do not
             set the var directly. 
            </summary>
            <remarks></remarks>
            <param name="Dial">Dial element to use. If null, no graphical needle is shown.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.Dials.Dial.DialResize" -->
        <member name="F:Arction.Gauges.Dials.Dial.m_DialElementAspect">
            <summary>
             Given Dial elements aspect ratio.
            </summary>
            <remarks>
            Default value 0.0 marks that the value has not yet been set. 
            Width / height of the given Dial elements desired size. 
            </remarks>
        </member>
        <member name="E:Arction.Gauges.Dials.Dial.DialElementChangedEvent">
            <summary>
             Notifies that the DialElement has been changed, due to 
             DialShape or direct interaction. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Dials.Dial.Angle">
            <summary>
             Angle of the Dial. Sets the value of the Dial as converterted
             by the current ValueMapper. 
            </summary>
            <remarks>
             Value is expected to be in degrees. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Dials.Dial.LengthFactor">
            <summary>
            Factor determining the Dials Length with LengthBaseline.
            Do not set both this and LengthFactor/LengthBaseline, as only the one set last counts.
            </summary>
            <remarks>
            <para>This property can not be set using style setters when the 
            Dial is part of a gauge. Use PrimaryScale.DialShape instead. </para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Dials.Dial.Length">
            <summary>
            Length to ValueMapper the Dial to. 
            Do not set both this and LengthFactor/LengthBaseline, as the one set last counts
            </summary>
            <remarks>
            <para>This property can not be set using style setters when the 
            Dial is part of a gauge. Use PrimaryScale.DialShape instead. </para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Dials.Dial.Center">
            <summary>
            Defines the rotation center for the current Dial element as a factor of the desired size. 
            </summary>
            <remarks>
            As noted, the value is a factor of desired size of unValueMapperd Dial, 
            when the Dial is pointing directly to the right (native position). 
            The value less than 0 and higher than 1 does not much sense, but are allowed. 
            <h2>Note about offsets and sizes</h2>
            If the Dials lenght is set as a factor, value 1 still sets the end point of the Dial to the 
            PrimaryScale, no matter where the rotation center is (this will pobably cause crash if the value is > 1).
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Dials.Dial.DialShape">
            <summary>
            The shape of the Dial. The Dial is element that controls 
            settings of the Dial and handles certaing scaling 
            functions, but does not handle the actual geometry creation, that
            is the job of DialElement. 
            DialShape is selector field to init DialElement with some 
            of the predefined element. 
            </summary>
            <remarks>
            <para>If user sets the DialElement directly, this is set to 
            DialShape.Custom. </para>
            <para>This property can not be set using style setters when the 
            Dial is part of a gauge. Use PrimaryScale.DialShape instead. 
            </para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Dials.Dial.DialTick">
            <summary>
            
            </summary>
            <remarks>
            <p>This might actually not work properly, if the TicksManager or 
            PrimaryScale.CustomTicksLine is init. after setting this.</p>
            </remarks>
            \todo Check if work when set last (after ticksline and ticksmanager).
            \todo Might not function so well with null input. 
        </member>
        <!-- Badly formed XML comment ignored for member "P:Arction.Gauges.Dials.Dial.DialElement" -->
        <member name="P:Arction.Gauges.Dials.Dial.ValueMapper">
            <summary>
             ValueMapper used by the Dial. 
             The actual ValueMapper is owned and set by the PrimaryScale. 
            </summary>
            <remarks>
            </remarks>
            \internal 
            Causes Dial angle update based on \ref m_Value with the new 
            ValueMapper (call to \ref UpdateAngle(bool))
        </member>
        <member name="P:Arction.Gauges.Dials.Dial.AspectRatio">
            <summary>
            Factor of the Dials thickness (width) in relation to the length.
            </summary>
            <remarks>
            Note that the length can be determined either by absolute values or by relative values (factor). 
            This does not care of the style the length is set, only it's final resulting length.
            This thus determines the aspect ratio of the Dial, and is thus bounded directly to the KeepAspectRatio, 
            which in-effect sets this to 1 when set to true.
            The set value is however remembered, thus setting KeepAspectRatio to 
            false again, returns the original set WidthFactor. 
            </remarks>
            \todo Does not seem to work from xaml 
        </member>
        <member name="P:Arction.Gauges.Dials.Dial.ColorCount">
            <summary>
             Returs the number of customizable colors. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Arction.Gauges.Dials.Dial.VisualChildrenCount">
            <summary>
            
            </summary>
        </member>
        <member name="T:Arction.Gauges.ValueMappers.ILinearValueMapper">
            <summary>
             Interface of the linear ValueMappers. 
            </summary>
            <remarks>
            <p>Linear ValueMapper value conversion can be accomplished by offset and gain value, that this interface requires 
            each linear ValueMapper to provide. These values in turn can be calculated by providing two pairs of corresponsing 
            values from each value-space.</p>
            </remarks>
            \todo We ought to provide setter for both walues in one call, of as range(s)
        </member>
        <member name="T:Arction.Gauges.ValueMappers.IValueMapper">
            <summary>
             Basic mapping class for mapping between gauge and its data source's values. 
             Current implementation is dummy placeholder, just raporting the given value back.
            </summary>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.IValueMapper.MapToSource(Arction.Gauges.Geo.Range)">
            <summary>
            Can take the direction into account
            </summary>
            <param name="GaugeRange"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.IValueMapper.MapToGauge(Arction.Gauges.Geo.Range)">
            <summary>
            Can take the direction into account
            </summary>
        </member>
        <member name="E:Arction.Gauges.ValueMappers.IValueMapper.ValueMapperModified">
            <summary>
             Generic notification of updet on the ValueMapper. The PropertyChanged gets usually fired multiple time on any change, this will only once.
            </summary>
        </member>
        <member name="T:Arction.Gauges.ValueMappers.IPolarValueMapper">
            <summary>
             Interface implemented by the polar ValueMappers.
            </summary>
            <remarks>
             Circular elements (that use polar coordinates) should use polar ValueMappers. 
            </remarks>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.IPolarValueMapper.MapToSource(System.Double,System.Boolean)">
            <summary>
             Maps target value (usually angle of gauge) to matchin source 
             value (actual data presented by the gauge).
             Takes the specified target area into account, by actually using 
             the given angles multiple that falls into the area between 
             given target area points. 
            </summary>
            
            <remarks>
             <para>Values not of which multiple does not fall into the range
             are handled so that they are ValueMapperd counting from the endpoint 
             they are closer to.</para>
             
             <para>An example of the difference to the Range.MapToSource():</para>
             <para>Lets assume target area definition is 180..0 (CW) and
             source area is 0..10. If value 360+90=450 is given, it's ValueMapperd 
             to value the proper range, to value 180-450mod360 = 90. 
             </para>
             
             <para>Note that the scaling to proper area is done only if 
             MultiRound property is false, or AllowMultiround parameter is 
             specifically set to false.</para>
            
            </remarks>
            <param name="TargetValue"></param>
            <param name="AllowMultiRound"></param>
            <returns></returns>
        </member>
        <member name="T:Arction.Gauges.ValueMappers.LinearPolarValueMapper">
            <summary>
             ValueMapper for polar coordinate system. 
             
            </summary>
            <remarks>
             <h1>Note:</h1>
             * Set target values can be modified according to the sweedirection and 
               other settings. 
            </remarks>
            <typeparam name="ValueMapperType"></typeparam>
            \internal
            \todo Name to LinearCylcicValueMapper or some suchc, as it's not actually 
            polar, it's just used in a polar setup, but the ValueMapper actually 
            (at least should) function correctly with other environments than just 
            cyclic liear areas of 2*pi. 
            \todo change to use range internally, much easier. 
        </member>
        <!-- Badly formed XML comment ignored for member "T:Arction.Gauges.ValueMappers.LinearValueMapper" -->
        <member name="M:Arction.Gauges.ValueMappers.LinearValueMapper.HandleValuehanged(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             
            </summary>
            <remarks>
            This mehtod must be called. If you inherit the class, make sure this is called. 
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.LinearValueMapper.MapToSource(System.Double)">
            <summary>
             Maps target value (usually angle of gauge) to matching source 
             value (actual data presented by the gauge).
            </summary>
            
            <remarks>
            s = (g-o)/f
            </remarks>
            <param name="GaugeValue"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.LinearValueMapper.MapToSource(Arction.Gauges.Geo.Range)">
            <summary>
             Maps target range (usually angles of a gauge) to matching source 
             value range (actual data presented by the gauge).
            </summary>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.LinearValueMapper.MapToGauge(System.Double)">
            <summary>
             Maps Source value (actual data presented by the gauge) to 
             target value (usually angle of a gauge)
            </summary>
            <param name="SourceValue"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.LinearValueMapper.MapToGauge(Arction.Gauges.Geo.Range)">
            <summary>
             Maps Source range (actual data presented by the gauge) to 
             target range (usually angles of a gauge)
            </summary>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.LinearValueMapper.CalcFactor">
            <summary>
             Calculates factor and offset from set source settigs. 
            </summary>
            <remarks>
            These calculations need to be checked, thy are just thrown in here. 
            
            F = T/S, Ta = Sa+O
            => O = Ta-Sa
            </remarks>
            
        </member>
        <member name="M:Arction.Gauges.ValueMappers.LinearValueMapper.CalcTargets">
            <summary>
            
            
            </summary>
            <remarks>
            T = S*F, T = Tb-Ta 
            => Ta = S*F+Ta
            </remarks>
        </member>
        <member name="P:Arction.Gauges.ValueMappers.LinearValueMapper.TargetA">
            <summary>
             Target space value matching SourceA value of Source space, automatically set by owning element.
            </summary>
            <remarks>
             Currently this property is set by PrimaryScale element automatically when its area range changes. There is 
             currently no way to prevent this. If you wish to use some other value, you should first set the PrimaryScale range, 
             and set this after it. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.ValueMappers.LinearValueMapper.TargetB">
            <summary>
             Target space value matching SourceB value of Source space, automatically set by owning element
            </summary>
            <remarks>
             Currently this property is set by PrimaryScale element automatically when its area range changes. There is 
             currently no way to prevent this. If you wish to use some other value, you should first set the PrimaryScale range, 
             and set this after it. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.ValueMappers.LinearValueMapper.Offset">
            <summary>
             Offset of the linear scaling.
            </summary>
            <remarks>
             The value is of source-value space. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.ValueMappers.LinearValueMapper.Factor">
            <summary>
             Calculated gaing of the linear scaling.
            </summary>
        </member>
        <member name="P:Arction.Gauges.ValueMappers.LinearValueMapper.AutoUpdateSettings">
            <summary>
             Controls the geomery update. If false, setting properties does not cause recalculation of factor and offset properties.
            </summary>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.LinearPolarValueMapper.MapToSource(System.Double)">
            <summary>
             Maps target value (usually angle of gauge) to matchin source 
             value (actual data presented by the gauge).
             Takes the specified target area into account, by actually using 
             the given angles multiple that falls into the area between 
             given target area points. 
            </summary>
            
            <remarks>
             <para>Values not of which multiple does not fall into the range
             are handled so that they are ValueMapperd counting from the endpoint 
             they are closer to.</para>
             
             <para>An example of the difference to the Range.MapToSource():</para>
             <para>Lets assume target area definition is 180..0 (CW) and
             source area is 0..10. If value 360+90=450 is given, it's ValueMapperd 
             to value the proper range, to value 180-450mod360 = 90. 
             </para>
             
            </remarks>
            <param name="TargetValue"></param>
            <returns></returns>
            \internal 
            s = (g-o)/f
        </member>
        <member name="M:Arction.Gauges.ValueMappers.LinearPolarValueMapper.MapToSource(Arction.Gauges.Geo.Range)">
            <summary>
             Maps the given target range to the source range. 
            </summary>
            <remarks>
            Difference to just calling MapToSource method with area endpoints 
            is that the handling of the ValueMappers (or the given ranges) 
            sweepdirection and scaling the range to a valid area before 
            conversion, based on the multiround scaling setting.
            
            As an example, lets assume that the ValueMappers source area is 0...10, 
            target area 180...0 and sweep direction clockwise. 
            if the queried area is 0..180 degrees, the direct mapping of 
            values will result in 10..0. 
            When using this method, the result is 10..20, as the start point of
            0 is mapped to value 10, and then the range is traversed in the 
            correct direction, clockwise, untill the multiplicate of queried 
            value (180) is meet at angle -180, and that value is converted. 
            
            </remarks>
            <param name="GaugeRange"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.LinearPolarValueMapper.MapToGauge(Arction.Gauges.Geo.Range)">
            <summary>
             Maps Source value (actual data presented by the gauge) to 
             target value (usually angle of a gauge)
            </summary>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.LinearPolarValueMapper.FixTargetB(System.Double)">
            <summary>
             Modify the used TargetB after setting, before calculating 
             offset/factor, acording to AllowMultiRound (m_MultiRound) property
             and other settings. 
            </summary>
            <remarks>
             See the static version
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.ValueMappers.LinearPolarValueMapper.FixTargetB(System.Double,System.Double,System.Windows.Media.SweepDirection,System.Boolean,System.Int32@)" -->
        <member name="M:Arction.Gauges.ValueMappers.LinearPolarValueMapper.HandleValuehanged(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Handles area property changes. calls base implementation.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.ValueMappers.LinearPolarValueMapper.CalcPivotValues">
            <summary>
            
            </summary>
            \bug possibly disposable class not disposed. 
        </member>
        <member name="F:Arction.Gauges.ValueMappers.LinearPolarValueMapper.m_MappingPivotTargetValue">
            <summary>
             value to usa as pivoting point when mapping source values to target values. 
            </summary>
            <remarks>
             Set when target area changes
            </remarks>
        </member>
        <member name="P:Arction.Gauges.ValueMappers.LinearPolarValueMapper.SweepDir">
            <summary>
            Sweep direction of the values.
            </summary>
            <remarks>
            <p>Affects the way values are ValueMapperd to the first positive circle round.</p>
            <p>Needs to be identical to the sweep direction of the owning polar component.</p>
            </remarks>
            \internal
            \note This is marked with Browsalble = false because the Prop. Editor seems 
            not to follow ReadOnly=true attributes for boolean / enum. types.  
            If the ValueMapper is part of an PrimaryScale, this can safely be hidden, but on 
            other ocations it might be needed.
        </member>
        <member name="P:Arction.Gauges.ValueMappers.LinearPolarValueMapper.AllowMultiRound">
            <summary>
             Defines if the targetB is ValueMapperd so that the circle can not be 
             wider than 360.
            </summary>
            <remarks>
            After setting this to true the system will forget the original 
            TargetB. 
            </remarks>
        </member>
        <member name="T:Arction.Gauges.Ticks.TickType">
            <summary>
             Define elsewhere
            </summary>
        </member>
        <member name="F:Arction.Gauges.Ticks.TickType.Major">
            Tick type has not yet been defined.
        </member>
        <member name="T:Arction.Gauges.Ticks.TickPropertyChangedEventArgs">
            <summary>
             Parameter type for ITickCalc.TickPropertyChanged event. 
            </summary>
        </member>
        <member name="T:Arction.Gauges.Ticks.ITicksManager">
            <summary>
             Interface for the ticks management system. 
             The interface does not state it, but it's expected to offer references to the minor and major lists right after
             it's been constrcuted. These references are used elsewhere
            </summary>
        </member>
        <member name="M:Arction.Gauges.Ticks.ITicksManager.MajorTickValue(System.Int32)">
            <summary>
             Getter for the calculated value of the specified major tick. 
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:Arction.Gauges.Ticks.ITicksManager.MinorTickValue(System.Int32)">
            <summary>
             Getter for the calculated value of the specified minor tick. 
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:Arction.Gauges.Ticks.ITicksManager.TertiaryTickValue(System.Int32)">
            <summary>
             Getter for the calculated value of the specified tertiary tick. 
            </summary>
            <param name="i"></param>
        </member>
        <member name="E:Arction.Gauges.Ticks.ITicksManager.MajorCountChanged">
            <summary>
             Count of the major ticks has been changed, either by div or count setting. 
            </summary>
        </member>
        <member name="E:Arction.Gauges.Ticks.ITicksManager.MinorCountChanged">
            <summary>
             Count of the minor ticks has been changed.
            </summary>
        </member>
        <member name="E:Arction.Gauges.Ticks.ITicksManager.TertiaryCountChanged">
            <summary>
             Count of the minor ticks has been changed.
            </summary>
        </member>
        <member name="E:Arction.Gauges.Ticks.ITicksManager.TickSettingsUpdated">
            <summary>
             Generic event descriping that some of the settings that define the tick positions have been modified. 
            </summary>
        </member>
        <member name="E:Arction.Gauges.Ticks.ITicksManager.TickPropertyChanged">
            <summary>
             Sent when some of the existing ticks property has been changed / modified. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.ITicksManager.MajorTics">
            <summary>
            List of Major Tics. 
            The class keeps these items up to date. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Arction.Gauges.Ticks.ITicksManager.MinorTics">
            <summary>
            List of Minor Tics. 
            The class keeps these items up to date. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.ITicksManager.TertiaryTicks">
            <summary>
            List of Tertiary Tics. 
            The class keeps these items up to date. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.ITicksManager.MajorTickCount">
            <summary>
            Number of major ticks. 
            When set, cause Div property to be recalculated. 
            When read, returns set or calculated value. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Arction.Gauges.Ticks.ITicksManager.MinorTickCount">
            <summary>
             Identical to the MajorTickCount, except affects the minor ticks. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.ITicksManager.TertiaryTickCount">
            <summary>
             Identical to the MajorTickCount, except affects the tertiary ticks. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.ITicksManager.MajorTickDiv">
            <summary>
             Division (distance) between major ticks. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.ITicksManager.MinorTickDiv">
            <summary>
             Division (distance) between minor ticks. 
             This can not be set, as the minor tics can only be changed using count. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.ITicksManager.TertiaryTickDiv">
            <summary>
             Division (distance) between minor ticks. 
             This can not be set, as the minor tics can only be changed using count. 
             Later, this might be removed, as only linear ticks support this kind of thinking.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.ITicksManager.TickOffset">
            <summary>
             Offset of the ticks. 
             Affects all the ticks through major ticks.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.TickChange.Geometry" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.TickChange.Dirty" -->
        <member name="T:Arction.Gauges.Tick">
            <summary>
             Class presenting single tick. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Tick.SetValue(System.Double)">
            <summary>
             private Setter method for m_Value. 
            </summary>
            <remarks>
             Not done on property setter, as it skips the setting if the new 
             matches the old one. The test is needs to be skipped if the ValueMapper 
             is modified or changes, thus we have this function that just sets
             the value.
            </remarks>
            <param name="?"></param>
        </member>
        <member name="M:Arction.Gauges.Tick.HandleValueMapperModifed(System.Object,System.EventArgs)">
            <summary>
             Handles situations where the ValueMapper (m_ValueMapper) is modified
            </summary>
            <remarks>
             Updates the ValueMapperd value of the tick based on set value, causing value change notifications. 
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.Tick.OnModification(Arction.Gauges.TickChange)">
            <summary>
             Notifies the parent list of changes made to the item.
            </summary>
            <remarks>
             Requires m_PNotif (NotifyParent property) to be true and a parent 
             list defined (m_List / List property). 
             The change notifications will accumulate until the requirements are true.
            </remarks>
            <param name="c"></param>
        </member>
        <member name="M:Arction.Gauges.Tick.OnLabelValueChange">
            <summary>
             If the user of this class modifies the label's settings, this 
             method should be called. It reports the modifications onwards. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Tick.m_List">
            
        </member>
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Tick.m_Index" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Tick.m_Type" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Tick.m_Value" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Tick.m_ValueMapperdValue" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Tick.m_Dirty" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Tick.m_Disabled" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Tick.m_Geometry" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Tick.m_Label" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Tick.m_LabelRect" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Tick.m_PNotif" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.Tick.m_PendingChanges" -->
        <member name="P:Arction.Gauges.Tick.ValueMapper">
            <summary>
             Setter of the ValueMapper. 
             Sets the ValueMapper reference for all existing ticks. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Tick.List">
            <summary>
            List of the tick. 
            </summary>
            <remarks>
            Settable only once. 
            If the tick has pending change on set of the list, the corresponding events will be sent. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Tick.Index">
            <summary>
            Index of the tick in the parent list. The list is responsible of updating this information
            </summary>
            <remarks>
            Negative value means that the index is unknown
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Tick.Geometry">
            <summary>
             Cache for the geometry of the line. This is just data storage, and does not know how to update the geometry
             properly
            </summary>
        </member>
        <member name="P:Arction.Gauges.Tick.Label">
            <summary>
             Lable object of the tick
            </summary>
        </member>
        <member name="P:Arction.Gauges.Tick.LabelRect">
            <summary>
             Positioning rect of the label.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Tick.NotifyParent">
            <summary>
             Property to temporarily disable parent notifications. For efficiency reasons, set this to false
             if more than one parameter is modified at once.
             The change notification will be sent when property is set to true, if some changes are not notified of.
            </summary>
        </member>
        <member name="T:Arction.Gauges.Ticks.TickList">
            <summary>
             Dummy collection that holds the ticks on a list, and notifies listeners of changes. 
             Note that one needs to call the NotifyChange() if a change has been made on the item, it has not
             yet been implemented on the tick level. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Ticks.TickList.OnTickChange(Arction.Gauges.Tick,Arction.Gauges.TickChange)">
            <summary>
             Intended to be called from the tick 
            </summary>
            <param name="t"></param>
        </member>
        <member name="E:Arction.Gauges.Ticks.TickList.TickModified">
            <summary>
             Sent when some of the existing ticks property has been changed / modified. 
            </summary>
        </member>
        <member name="E:Arction.Gauges.Ticks.TickList.TickDirty">
            <summary>
             Sent when some of the ticks have become dirty. 
            </summary>
        </member>
        <member name="E:Arction.Gauges.Ticks.TickList.CollectionChanged">
            <summary>
            
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.TickList.Count">
            <summary>
             Number of ticks in the list. 
            </summary>
            <remarks>
            Note that this is not the corresponding (active) tick count, but the total number of initialized items, that 
            can be much larger than the current tick count. Use active count to get the current TickCount of the correct type.
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Ticks.TickList.TickCount">
            <summary>
             Tick count of the correct type. 
            </summary>
            <remarks>
            Note that this does not work, if the 
             TickList is not initialized / handled properly by the TicksManager. 
             </remarks>
            <returns></returns>
        </member>
        <member name="T:Arction.Gauges.Ticks.TicksManager">
            <summary>
            
            </summary>
            <remarks>
             Can be bound to a single PrimaryScale at a time, because the TickList objects 
             contain PrimaryScale-specific data / objects, and those items must be clread 
             by the old PrimaryScale before the new one can use this. 
            </remarks>
            \bug This inherits \b temporarilly the FrameworkElement. The class is NOT visual, thus we should not do this, 
            styles however require that... The "final" solution is to move the dependency properties (either as attached 
            proeprties or depProps) to the PrimaryScale side. This is the implementing side, that is the defining side.
            
            \note this object uses PrimaryScale' ValueMapper and SourceRange, and trusts that they are always properly set. 
            \bug When ValueMapper is set to null, will not disable ticks (as would be logical). This is so because 
            the class trusts the m_MajTickCount value to be correct (represent the count of active - not disabled - ticks. 
            If the ticks are disabled without changing the property, the ticks enabling might crash or be problematic, 
            and if we change the value, we might be overriding user set values. We could hold the true disabled count on 
            memory, but that might cause trouble as well. Not fixed as the whole system needs an overhaul and the 
            problem will go away at that point. 
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.Finalize">
            \name Construction 
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.#ctor">
            <summary>
             
            </summary>
            <param name="ParentScale"></param>
        </member>
        <member name="F:Arction.Gauges.Ticks.TicksManager.m_SourceRange">
            <summary>
             The source value area to calculate tick positions for. 
             See Area property setter's documentation for more information. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.GetTickCount(Arction.Gauges.Ticks.TickList)">
            <summary>
             returns the ACTIVE / set tick count of the given list. 
             This is greatly different from the number from the actual tick elements. 
            </summary>
            
            <Remarks>
            The list must be owned by this object. -1 is returned otherwise.
            The Custom tics is a special case, and number of the lists contents is returned. 
            </Remarks>
            
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.SetTickCount(Arction.Gauges.Ticks.TickList,System.Int32)">
            <summary>
             Sets the the ACTIVE / set tick count of the given list. 
            </summary>
            
            <Remarks>
            The list must be owned by this object. -1 is returned otherwise.
            The Custom tics is a special case, and it's count cant be set. 
            the setting fails quietly
            </Remarks>
            
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.MajorTickValue(System.Int32)">
            <summary>
             Getter for the calculated value of the specified major tick. 
            </summary>
            <remarks>
            We don't actually want to return the real i'th indexes position if 
            (and when) the offset is large enough to move the tick over an 
            other position, thus the offsets effect is capped to div. 
            </remarks>
            <param name="i"></param>
            
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.MinorTickOffset(System.Int32)">
            <summary>
             Calculates the offset of the given minor tick index. The index is the
             number of the index starting from 0 at the prev. major tick.
             Fort The actual position, you need to add the position of the proper
             major tick position. 
            </summary>
            <param name="Index"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.TertiaryTickOffset(System.Int32)">
            <summary>
             Calculates the offset of the given tertiary tick index. The index is the
             number of the index starting from 0 at the prev. major tick.
             Fort The actual position, you need to add the position of the proper
             major tick position. 
            </summary>
            <param name="Index"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.MinorTickValue(System.Int32)">
            <summary>
             Getter for the calculated value of the specified minor tick. 
            </summary>
            
            <remarks>
            DO NOT use this to calculate the values on generation phase, as 
            this trusts that computation to be done already. 
            </remarks>
            
            <param name="i"></param>
            
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.TertiaryTickValue(System.Int32)">
            <summary>
             Getter for the calculated value of the specified minor tick. 
            </summary>
            <param name="i"></param>
            
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.Calc">
            <summary>
             Calculates the division or count, depending on m_CalcType. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.Ticks.TicksManager.CalcDiv" -->
        <member name="M:Arction.Gauges.Ticks.TicksManager.CalcCounts">
            <summary>
             Calculates and sets Major tick count from current values, namely offset and MajorDiv. 
             Causes the tic values to be updated (events emitted)
            </summary>
            <remarks>
            This ought to be the only place where the count of items change.
            </remarks>
            \internal 
            \todo Currently this function limits the count of the ticks to 1000 items. 
            The implementation is not pretty, and needs to change. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.Ticks.TicksManager.SetMajTickCount(System.Int32,System.Int32,System.Boolean)" -->
        <member name="M:Arction.Gauges.Ticks.TicksManager.UpdateMajTickValues">
            <summary>
             Causes update events on each ticks value. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.UpdateMinTicks">
            <summary>
            
            </summary>
            \bug Does not handle m_MinCount = 0 situation. 
        </member>
        <member name="M:Arction.Gauges.Ticks.TicksManager.HandleValueMapperModified(System.Object,System.EventArgs)">
            <summary>
             Handler of the m_ValueMapper changes. We'll assume that the source
             values have changed and try to update the internal m_SourceRange and
             re-calculate the ticks. 
            </summary>
            <param name="sender">Not cared currently. Exists for future compatibility.</param>
            <param name="e">Not cared currently. Exists for future compatibility.</param>
        </member>
        <member name="E:Arction.Gauges.Ticks.TicksManager.PropertyChanged">
            <summary>
             Notifies of the changed properties
            </summary>
        </member>
        <member name="E:Arction.Gauges.Ticks.TicksManager.MajorCountChanged">
            <summary>
             Count of the major ticks has been changed.
            </summary>
        </member>
        <member name="E:Arction.Gauges.Ticks.TicksManager.MinorCountChanged">
            <summary>
             Count of the minor ticks has been changed.
            </summary>
        </member>
        <member name="E:Arction.Gauges.Ticks.TicksManager.TertiaryCountChanged">
            <summary>
             Count of the minor ticks has been changed.
            </summary>
        </member>
        <member name="E:Arction.Gauges.Ticks.TicksManager.TickSettingsUpdated">
            <summary>
             Generic event descriping that some of the settings that define the tick positions have been modified. 
            </summary>
            \bug newer sent, either remove or start using, this.
        </member>
        <member name="E:Arction.Gauges.Ticks.TicksManager.TickPropertyChanged">
            <summary>
             Sent when some of the existing ticks property has been changed / modified. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.ValueMapper">
            <summary>
             Setter of the ValueMapper. 
             Sets the ValueMapper reference for all existing ticks. 
            </summary>
            <remarks>
             Set automatically by PrimaryScale when added to it. 
             The TicksManager does not function if set to null. 
            </remarks>
            \internal 
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.MajorTics">
            <summary>
            List of Major Tics. 
            The class keeps these items up to date. 
            </summary>
            <returns></returns>
            \bug Will crash if set after init
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.MinorTics">
            <summary>
            List of Minor Tics. 
            The class keeps these items up to date. 
            </summary>
            
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.TertiaryTicks">
            <summary>
            List of tertiary Tics. 
            The class keeps these items up to date. 
            </summary>
            
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.DialTick">
            <summary>
             A special Dial, resreverd to be bound to the Dial position. 
            </summary>
            <remarks>
             At least for now, this is just testing. The manager just holds this, 
             but does not handle it. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.MajorTickCount">
            <summary>
            Number of major ticks. 
            When set, cause Div property to be recalculated. 
            When read, returns set or calculated value. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.TertiaryTickCount">
            <summary>
             Identical to the MajorTickCount, except affects the minor ticks. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.MajorTickDiv">
            <summary>
             Division (distance) between major ticks. 
            </summary>
            <remarks>
            It should be noted that this is only valid and definable information if the div is 
            constant and that it's not on logarithmic ValueMapper. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.MinorTickDiv">
            <summary>
             Division (distance) between minor ticks. 
            </summary>
            <remarks>
            One can only set count of the minor ticks, division is calculated from that. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.TertiaryTickDiv">
            <summary>
             Division (distance) between tertiary ticks. 
            </summary>
            <remarks>
            One can only set count of the tertiary ticks, division is calculated from that. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.TickOffset">
            <summary>
             Offset of the ticks values. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Ticks.TicksManager.FullCircle">
            <summary>
            Determines if the start and end ticks will collide (their angle is 
            the same in radial gauge). 
            This being true causes the last major tick to be left out
            </summary>
            <remarks>
            <para>Set by PrimaryScale through internal interface. Currently not controllable by user.</para>
            </remarks>
            \internal
            This needs to be set for the final tick to work correctly 
            (could we actually do the hiding in the TicksLine?? Would it be 
            confusing?? there we would (possibly) have direct knowledge of the 
            drawing area). 
        </member>
        <member name="T:Arction.Gauges.Ticks.TicksManager.CalcType">
            \name Types and enums
        </member>
        <member name="T:Arction.Gauges.ArcLine">
            <summary>
            Capsules an arg segment of a circle. Later this might become an arc of an ellipse. 
            </summary>
            <remarks>
            Drawing is done using path and ArcGeometry classes. The other option would have been to actually inherit the
            path. 
            <h1>size definition and usage</h1>
            The object will take space only so much it needs. Set the radius to wished value and read the CenteringOffset
            property and position the produced image to that offset, to center the drawn arc to the center of the 
            imaginary circle of the defined radius. 
            Later there might be autoStretch, that would stretch the item to the value given at measure, but currently 
            Radius must be defined explicitly (for example, right before measure). 
            <h2>Updates</h2>
            Each property setting marks the object as "dirty" setting m_GeometryDirty to true. The value is returned to 
            false on arc geometrys geometryUpdate call, at MeasureOverride or at UpdateGeometry function. 
            Set properties are not directly propagated to the underlying geometry, but only at UpdateGeometry call();
            Some of the settings will allso invalidate measure-call, and will cause the Meausre call to actually do 
            re-measurement of the underlying path. This state is stored in m_MeasureDirty. 
            
            </remarks>
        </member>
        <member name="M:Arction.Gauges.ArcLine.#ctor">
             \name Construction and Init
            @{
        </member>
        <member name="M:Arction.Gauges.ArcLine.MeasureOverride(System.Windows.Size)">
            <summary>
             Calculates the space requirement for the arc. 
            </summary> 
            <remarks>
             The returned space contains the empty space on the left-top side of the actual visible arc. 
             This can (will) cahnge if (when) the ArcGeometry is modified to produce different kind of geometry, that 
             does not hold that space reserved.
            </remarks>
             \todo The size of the path is recalculated as it's endpoints change. This might not be necessary, if we 
              handle the arrange allways with the full rectangle, thus we would not need the actual full size. 
              Not sure which one is faster, either report unnecessary space requirements (the screen seems
              not to update the extra space) and run the measureOverride less often, or report smaller space, but
              run it more often. 
              
             <h1>about calculating the required space </h1>
             Note about calculating the required space of the path. It does NOT calculate the part that goes to negative 
             side. As an effect, on this scenario we get wrong desired size by half the strokewidth. On Dials case, 
             it might be a lot larger differenc, because of the small angles that produce long lines. 
             
             Currently I have come up with just two way to fix the problem. 
              * Rotate the geometry and run the measure 2 or 4 times (one querter or half at a time), keeping the 
                center of the geometry at origo, or at either PrimaryScale but far a way from origo. Combine the information of 
                the desired sizes. The Path draws the item correctly. The only problem is finding out what size it is. 
              * Remove the effect of strokethickness, by setting it to 0, dublicatin ValueMapperd version of the geometry, 
                combining forms and using fill instead. 
              
             Other kind of solutions would be:
              * Manually calculate the desired size. 
              * Estimate the amount the item goes into negative side, and move it that much into the positive side, 
                leaving just enough gab for the measure to succeed. 
              * Kind of ignore the strokethickness by doing arrange using the simple geometry. This can lead to 
                situations where the area is clipped. 
              * Make sure we're reserving enough space around the object, thus preventing clipping, but at the same time
                this might slow things down as hit-tests might return unnecessary hits. 
             
             Things to check:
              * When is the truesize ready?
              * When is the RederedSize ready?
                
             Current solution:
              * Draw the geometry half of strokethickness away from axes, take this into account at arrange.
             
              
        </member>
        <member name="M:Arction.Gauges.ArcLine.ArrangeOverride(System.Windows.Size)">
            <summary>
            
            </summary>
            <remarks>
            The function assumes that given finalSize is the same as return from 
            measure as desiredsize. 
            </remarks>
            <param name="finalSize"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.ArcLine.GetMinRadEstimate">
            <summary>
            Calculates the maximum required offset that needs to be added to the radius, so that we get the required space. 
            Kind of a MinSize, except internally calculated, not settable, and not necessarilly exact
            </summary>
            <remarks>
            With rectangle like items we might change this to return size. 
            </remarks>
        </member>
        <member name="M:Arction.Gauges.ArcLine.GetReqRad(System.Windows.Size)">
            <summary>
             Calculates the radius of the arc so that arcline will still fit into it
            </summary>
            <remarks>
            Used as a part of the higher level layout, so that the PrimaryScale does not
            have to run the whole measure round. 
            </remarks>
            <param name="UseSize"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.ArcLine.UpdateGeometry(System.Boolean)">
            <summary>
             Updated the geometry of the arc geometry, thus updating the path. 
             This should be done prior measure round. 
             Measure and Arrange overrides will check if this is run after the last time, 
             and will skip it's task if nothing has changed (to be done).  
            </summary>
        </member>
        <member name="M:Arction.Gauges.ArcLine.OnGeometryUpdate">
             \name Event launchers
             Protected function that cause the events to be emitted. 
            @{
        </member>
        <member name="M:Arction.Gauges.ArcLine.HandleArcGeometryUpdated(System.Object,System.EventArgs)">
            <summary>
             Handler for the ArcGeometryContro.GeometryUpdated (m_ArcGeo) event, 
             in effect called when the Range-property is modified and our 
             size has probably changed. 
            </summary>
            <remarks>
             Causes measure invalidation. 
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.ArcLine.HandleSizeChange(System.Object,Arction.Gauges.SizeChangeEventArgs)">
            <summary>
             Handles tasks associated with the chancing of size. Bound to the m_Size member. 
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.ArcLine.HandleStrokeChanged(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Handler for the Stroke property. 
            </summary>
            <remarks>
            <para>Simply sets the Paths stroke property. Not done with binding 
            as the SL Browser plugin seems to crash on it. Out of browser it
            works fine. 
            </para>
            </remarks>
            <param name="sender">Ignored</param>
            <param name="e">Ignored</param>
        </member>
        <member name="M:Arction.Gauges.ArcLine.HandleStrokeThicknessChanged(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Event handler bound to the StrokeThickness property
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.ArcLine.MarkDirty">
            <summary>
             
            </summary>
            \todo Find out if this is really required anymore.
        </member>
        <member name="M:Arction.Gauges.ArcLine.Init">
            <summary>
             Initializes the UI components
            </summary>
            <remarks>
             This function must be run only once. Think of this as part of the constructor. 
            </remarks>
        </member>
        <member name="F:Arction.Gauges.ArcLine.m_Size">
            Size of the arc. 
            Set by \ref Size property
        </member>
        <member name="F:Arction.Gauges.ArcLine.m_Stroke">
            <summary>
             Cache of the Stroke property. 
             Bound to m_Path members 'Stroke' property. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.ArcLine.m_StrokeThickness">
            <summary>
             Cache of the StrokeThickness property. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ArcLine.m_ArcGeo" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ArcLine.m_GivenMeasureSize" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ArcLine.m_LastDS" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ArcLine.m_MeasureDirty" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ArcLine.m_GeometryDirty" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ArcLine.d_ItemIndex" -->
        <!-- Badly formed XML comment ignored for member "F:Arction.Gauges.ArcLine.d_CreatedCount" -->
        <member name="E:Arction.Gauges.ArcLine.PropertyChanged">
            <summary>
             Emitted when the geometry is updated. 
            </summary>
        </member>
        <member name="E:Arction.Gauges.ArcLine.GeometryUpdated">
            <summary>
             Emitted when the geometry is updated. 
            </summary>
        </member>
        <member name="E:Arction.Gauges.ArcLine.CenteringOffsetUpdated">
            <summary>
             Sent when the centering update changes. This usually (but not necessarilly) happens when Start- or 
             AngleEnd is changed. 
             The callback function is of type CenteringOffsetUpdatedArgs.
            </summary>
        </member>
        <member name="P:Arction.Gauges.ArcLine.Size">
            <summary>
            Size of the PrimaryScale line
            </summary>
            \bug Outer, inner and conent radius are not calculated or updated.
        </member>
        <member name="P:Arction.Gauges.ArcLine.Range">
            <summary>
             Range of the arc, meaning Staring and Ending angles, and the sweeping direction. 
            </summary>
            \internal 
            Pass-through property for ArgGeometryControl.
        </member>
        <member name="P:Arction.Gauges.ArcLine.CenterToBoxLT">
            <summary>
             Vector from the current bounding box top-left corner to the center
             of the virtual full cirlce this is part of. 
            </summary>
            <remarks>
             To get the original circles top-left corner, use the defined radius. 
            
             Value calculated on geometry update.
            </remarks>
            \todo To be removed, from here and from interface. Use ContentCenter instead. 
        </member>
        <member name="P:Arction.Gauges.ArcLine.ContentCenter">
            <summary>
             Getter of the coordinates (as vector from lt-corner) of the content 
             center.
            </summary>
        </member>
        <member name="P:Arction.Gauges.ArcLine.Stroke">
            <summary>
             Stroke brush of the arc line.
            </summary>
            \internal
            Value kept on m_Stroke member
        </member>
        <!-- Badly formed XML comment ignored for member "P:Arction.Gauges.ArcLine.StrokeCache" -->
        <member name="P:Arction.Gauges.ArcLine.StrokeThickness">
            <summary>Stroke thickness of the arc line.</summary>
            <remarks>If null, the ArcLine is not drawn, and requires no size. </remarks>
            \internal
            Bound to HandleStrokeThickness() method.
            Value kept on m_StrokeThickness member
        </member>
        <!-- Badly formed XML comment ignored for member "P:Arction.Gauges.ArcLine.StrokeThicknessCache" -->
        <member name="T:Arction.Gauges.ArcLine.CenteringOffsetUpdatedArgs">
            @}
        </member>
        <member name="T:Arction.Gauges.Scale">
            <summary>
            
            </summary>
            \note This object is actuall polar PrimaryScale, will need great modifications to
                  support direct axes. 
            \bug there is no event notifyin change of the ValueMapper object. 
            \todo There is no way to define the sweepdirection of the PrimaryScale. ArcLine and ValueMapper uses the sweepdirection of 
            the internal m_TargetRange, but it's not settable. 
            \todo a separate ValueMapper object init in XAML is normally needed only so that user can set the value (source) range
            to show in the PrimaryScale. Because of this, this property should be brought up to the PrimaryScale level
        </member>
        <member name="M:Arction.Gauges.Scale.HandleTickCountChanged(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Handles MajorTickDiv and MajorTickCount value transfer to the 
             TicksManager.
            </summary>
            <remarks>
            <para>The way this currently works, effectively prevents binding 
            to the TicksManager properties.</para>
            <para>
            Assumes that major div is updated instantly on setting of count, 
            and vice versa. 
            </para>
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.Scale.Unsubscribe">
            <summary>
             The PrimaryScale has been discarded, and ought to return to disengage 
             from the given items.
            </summary>
        </member>
        <member name="F:Arction.Gauges.Scale.m_Usable">
            <summary>
             Describes if the PrimaryScale is successfully initialized, but not deinitialized. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Scale.HandleAngleChaged(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Handles changes in the AngleBeginProperty and AngleEndProperty.
            </summary>
            <remarks>
             <para>Sets the m_TargetRange, that in turns calls the HandleTargetAreaChanged handler. 
             Donet his way as the range might change at some other point as well. </para>
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="F:Arction.Gauges.Scale.ArcStrokeProperty">
            <summary> DependecyProperty of the ArcStrokeproperty </summary>
        </member>
        <member name="F:Arction.Gauges.Scale.m_ArcStroke">
            <summary>
             Cache of the Stroke property. 
             Bound to m_Path members 'Stroke' property. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Scale.ArcStrokeThicknessProperty">
            <summary>DependecyProperty of the StrokeThickness property</summary>
        </member>
        <member name="F:Arction.Gauges.Scale.m_ArcStrokeThickness">
            <summary>
             Cache of the StrokeThickness property. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Scale.HandleValueIndPosValueChanged(System.Object,System.EventArgs)">
            <summary>
             Handler of the changes in current m_ValueIndPos fields.
            </summary>
            <remarks>
            Updates the three DP's internal values from the curren m_ValueIndPos
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.Scale.HandleTargetAreaChanged(System.Object,System.EventArgs)">
            <summary>
             Either AngleBegin or AngleEnd has changed.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="F:Arction.Gauges.Scale.m_ValueMapper">
            <summary>
             ValueMapper of the scale and all it's components. 
            </summary>
            <remarks>
            <para>Kept as IValueMapper, even though it is currently allways LinearPolarValueMapper, as it's the only 
            one implemented. Later user might be offered either posibility to choose mapper type (linear, logarithmic, 
            etc.), or give the mapper object itself. The kept type is the Interface so that we do not accidentaly 
            make too wide assumptions and block the possibility of change. 
            </para>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.Scale.HandleRadiusChange(System.Object,Arction.DProp.DPChangedEventArgs)" -->
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.Scale.MeasureOverride(System.Windows.Size)" -->
        <member name="M:Arction.Gauges.Scale.ArrangeOverride(System.Windows.Size)">
            <summary>
             
            </summary>
            <remarks>
            <H1>Unnecessary calls</H1>
            The parameters should be cached, as we might end up here in vain, as in WPF
            setting ArcLines paths start/end will cause an arrange invalidation of at least this object. 
            
            </remarks>
            <param name="finalSize"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Scale.SetValueMapperTargetArea">
            <summary>
             Delivers current TargetRange to the m_ValueMapper object. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Scale.HandleLightDirectionChange(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Called when the parent gauges light direction value changes.
             Updates elements when light direction changes.
            </summary>
            <remarks>
             (we probably should have our own property as well).
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="F:Arction.Gauges.Scale.m_LightDirectionRad">
            <summary>
             Angle of the given light direction in reversed degrees.
             Directly suitable for the effect's direction... or not. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Scale.LightUpdate">
            <summary>
             Updates elements lighth direction effects, based on 
             m_LightDirectionDeg value. 
            </summary>
            <remarks>
            Currently only knows how to handle DropShadowEffect.
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Scale.SetTick(Arction.Gauges.TicksLine@,Arction.Gauges.TicksLine,Arction.Gauges.Ticks.TickList)">
            <summary>
             Setting given internal TicksLine member to a new value. 
             This is intended for the use of TicksLine setters. 
            </summary>
            <param name="m_MajTicksLine"></param>
            <param name="value"></param>
            <param name="tickListm"></param>
        </member>
        <member name="M:Arction.Gauges.Scale.SyncDialColors">
            <summary>
             Updates DialColorX properties form the Dial, if the properties
             are not set. Otherwise does the opposite.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Scale.HandleDialElementChanged(System.Object,System.EventArgs)">
            <summary>
             Ponter's Dial element has changed.
             Syncs the colors between own properties and Dial element.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.Scale.HandleBorderContentRadiusChanged(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Kind of handles border content radius -> this radius updates. 
             Could of been done with binds as well, figured this might be faster.... or not. 
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.Scale.HandleBorderGeometryChanged(System.Object,System.EventArgs)">
            <summary>
             Invalidates this and m_Panels measure, as we can assume that the
             geometry change of the border does affect our own size.
            </summary>
            <remarks>
             Called on border geometrys changes. This might happend during own 
             measurement call. 
             Emits our own GeometryChangedEvent
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="F:Arction.Gauges.Scale.m_ParentGauge">
            <summary>
             The parent gauge element. 
            </summary>
            <remarks>
            <para>Used for getting light direction changes and causign the measurement invalidation in the parent. </para>
            </remarks>
        </member>
        <member name="F:Arction.Gauges.Scale.m_ReqSize">
            <Summary>Last returned desired size from the MeasureOverride. </Summary>
        </member>
        <member name="F:Arction.Gauges.Scale.m_GivenSize">
            <Summary>The size given to this in measurement </Summary>
        </member>
        <member name="F:Arction.Gauges.Scale.m_Dirty">
            <Summary>Defines if the measurement should be allowed to be run. </Summary>
        </member>
        <member name="F:Arction.Gauges.Scale.m_Panel">
            <Summary>The internal panel to handle the childs.  </Summary>
        </member>
        <member name="F:Arction.Gauges.Scale.m_TargetRange">
            <Summary>Angle range/direction to draw the PrimaryScale to. </Summary>
        </member>
        <member name="F:Arction.Gauges.Scale.m_PrevBorderRad">
            <Summary>Current Borders OuterRad. Used in preventing unnecessary panel measure calls.</Summary>
        </member>
        <member name="F:Arction.Gauges.Scale.m_Arc">
            <Summary>The arc line element. </Summary> 
        </member>
        <member name="F:Arction.Gauges.Scale.m_CustomTicksLine">
            <Summary>Custom tics </Summary> 
        </member>
        <member name="F:Arction.Gauges.Scale.m_MajTicksLine">
            <Summary>Major tics </Summary> 
        </member>
        <member name="F:Arction.Gauges.Scale.m_MinTicksLine">
            <Summary>Minor tics </Summary> 
        </member>
        <member name="F:Arction.Gauges.Scale.m_TertiaryTicksLine">
            <Summary>Tertiary tics </Summary> 
        </member>
        <member name="F:Arction.Gauges.Scale.m_CenterMarker">
            <Summary>Debugging marker for the contentcenter </Summary> 
        </member>
        <member name="F:Arction.Gauges.Scale.m_ThemeDic">
            <summary>
             Dictionary containing styles and templates for currently selected theme.
            </summary>
        </member>
        <member name="F:Arction.Gauges.Scale.d_CreatedCount">
             \name Debugging members
            @{
        </member>
        <member name="E:Arction.Gauges.Scale.DialChangedEvent">
            <summary>
             Emitted when Dial PrimaryScale Dial changes. 
            </summary>
            <remarks>
             The ownership (visual parent) of the Dial is expected to change after (during) this event, 
             as the Guage will move the item to part of its own visual tree. 
             !! NOT TRUE, the Dial ownership notification is handled differently through direct method calls.
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.AdjacentPadding">
            <summary>
             
            </summary>
            <remarks>
            Also see ArcPadding. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.RoundBorder">
            <summary>
             Defines how to draw the border stroke at the AdjacentPadding area. 
             If true, the area is drawn as arc, if falce a straight line is used. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Scale.ArcStroke">
            <summary>
             ArcStrokebrush of the arc line.
            </summary>
            \internal
            Value kept on m_ArcStrokemember
        </member>
        <member name="P:Arction.Gauges.Scale.ArcStrokeThickness">
            <summary>ArcStrokethickness of the arc line.</summary>
            \internal
            Bound to HandleStrokeThickness() method.
            Value kept on m_StrokeThickness member
        </member>
        <member name="P:Arction.Gauges.Scale.DialShape">
            <summary>
            The shape of the Dial. The Dial is element that controls 
            settings of the Dial and handles certaing scaling 
            functions, but does not handle the actual geometry creation, that
            is the job of DialElement. 
            DialShape is selector field to init DialElement with some 
            of the predefined element. 
            </summary>
            <remarks>
            <para>If user sets the DialElement directly, this is set to t
            DialShape.Custom.</para>
            <para>Bound internally to the current Dial's matching property 
            as a one-way binding. In styles, use this property, otherwise 
            the Dials property can be directly if so required.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.DialLengthFactor">
            <summary>
             Factor determining the Dials Length with LengthBaseline.
             Do not set both this and DialLengthFactor/DialLengthBaseline, as only the one set last counts.
            </summary>
            <remarks>
            <para>Bound internally to the current Dial's matching property 
            as a one-way binding. In styles, use this property, otherwise 
            the Dials property can be directly if so required.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.DialLength">
            <summary>
            DialLength to ValueMapper the Dial to.
            Do not set both this and DialLengthFactor/DialLengthBaseline, as only the one set last counts.
            </summary>
            <remarks>
            <para>Bound internally to the current Dial's matching property 
            as a one-way binding. In styles, use this property, otherwise 
            the Dials property can be directly if so required.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.DialColor1">
            <summary>
            Primary color of the Dial. 
            Note that the actual use of the color depends on the selected Dial element / shape. 
            </summary>
            <remarks>
            <para>The number of the available colors also varies per Dial element. If there are less than 
            three colors supported by the Dial, rest of the properties are just ignored. 
            If there is more, they can not be controlled using these properties.
            For better control over the colors, use Dial.SetColor() or IColoredNeedle.SetColor() methods.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.DialColor2">
            <summary>
            Secondary color of the Dial. 
            Note that the actual use of the color depends on the selected Dial element / shape. 
            </summary>
            <remarks>
            <para>The number of the available colors also varies per Dial element. If there are less than 
            three colors supported by the Dial, rest of the properties are just ignored. 
            If there is more, they can not be controlled using these properties.
            For better control over the colors, use Dial.SetColor() or IColoredNeedle.SetColor() methods.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.DialColor3">
            <summary>
            Tertiary color of the Dial. 
            Note that the actual use of the color depends on the selected Dial element / shape. 
            </summary>
            <remarks>
            <para>The number of the available colors also varies per Dial element. If there are less than 
            three colors supported by the Dial, rest of the properties are just ignored. 
            If there is more, they can not be controlled using these properties.
            For better control over the colors, use Dial.SetColor() or IColoredNeedle.SetColor() methods.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.Dial">
            <summary>
             Dial object of the PrimaryScale. 
            </summary>
            <remarks>
             <para>The outlook of the Dial itself can be controlled using 
             PrimaryScale-objects properties, and this object ought to be used only 
             in more specialized circuimstances. </para>
            </remarks>
            \note sdfsd
        </member>
        <member name="P:Arction.Gauges.Scale.ValueIndicator">
            <summary>
             Text field that shows the current value. 
             Note that the ValueIndicator is hidden by default, and must be 
             manually set to be visible. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Scale.ValueIndicatorAngle">
            <summary>
            Angle of the value indicator field
            </summary>
        </member>
        <member name="P:Arction.Gauges.Scale.ValueIndicatorDistance">
            <summary>
            Distance of the value indicator field
            </summary>
        </member>
        <member name="P:Arction.Gauges.Scale.ValueIndicatorDistanceType">
            <summary>
            Type of the specified value indicator fields distance.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Scale.ValueIndPosition">
            <summary>
             Position of the value indicator field.
            </summary>
            <remarks>
            <para>Values of this is controlled through ValueIndicatorDistanceType, ValueIndicatorDistance and 
            ValueIndicatorAngle properties as well.</para>
            </remarks>
            \internal
            \bug Does not handle null values properly.
        </member>
        <member name="P:Arction.Gauges.Scale.ParentGauge">
            <summary>
             Setter / getter of the parent gauge. 
            </summary>
            <remarks>
             PrimaryScale can function outside a gauge, but being inside the gauge affects some of the functionality. 
             Setting the parentGauge causes this object to receive light direction information from the gauge. 
             Also, if the gauge is set, it's expected that the gauge will take ownership of the Dial, and handles
             it's measurement and arrange. This is necessary, as gauge might have multiple Scalees, and each Scalees Dial
             needs to be drawn abowe the other Scalees. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.ValueFormat">
            <summary>
             Format to present the value of the value presentation box.
            </summary>
            <remarks>
            If "", Dial tick labels format is used instead. </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.Label">
            <summary>
             Getter of the label textblock.
            </summary>
            <remarks>
             This property might be removed quite fast, as we might want (need) to capsule the actual visual object. 
             For intance, the LabelPosition would be better implemented as attached property or labels own member. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.LabelAngle">
            <summary>
            Angle of the value indicator field
            </summary>
        </member>
        <member name="P:Arction.Gauges.Scale.LabelDistance">
            <summary>
            Distance of the value indicator field
            </summary>
        </member>
        <member name="P:Arction.Gauges.Scale.LabelDistanceType">
            <summary>
            Type of the specified value indicator fields distance.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Scale.LabelPosition">
            <summary>
             Position of the label. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Scale.TicksManager">
            <Summary>
             Ticks manager object of the PrimaryScale. 
             PrimaryScale ought to allways have a ticks manager. If this is set to 
             null, the PrimaryScale creates a default ticks manager. 
            </Summary>
            \todo Check if this can be changed so we handel ITicksManager interaface objects, instead of real ones. 
        </member>
        <member name="P:Arction.Gauges.Scale.MajorTickDiv">
            <summary>
             Division (distance) between major ticks. 
            </summary>
            <remarks>
            It should be noted that this is only valid and definable information if the div is 
            constant and that it's not on logarithmic ValueMapper. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.MajorTickCount">
            <summary>
            Number of major ticks. 
            When set, cause Div property to be recalculated. 
            When read, returns set or calculated value. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Arction.Gauges.Scale.TertiaryTickCount">
            <summary>
             Identical to the MajorTickCount, except affects the minor ticks. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Scale.Value">
            <summary>
             Value of the PrimaryScale; the value the Dial of the PrimaryScale points to, in source value space of the ValueMapper.
            </summary>
            <remarks>
            <p>Internally bound to the Dials "Value" property.</p>
            <p>To control the angle directly, use Dials "Angle" property instead.</p>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.ValueCache">
            <summary>
             Cached value of the "Value" property. Usefull as has an event that can be bound to. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Arction.Gauges.Scale.ValueMapper" -->
        <member name="P:Arction.Gauges.Scale.Radius">
            <summary>
             Setter of the radius as an absolute value. 
            </summary>
            <remarks>  
             
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.RadiusFactor">
            <summary>
             Radius of the arc, as factor of the defined RadiusBaseline. 
            </summary>
            <remarks> 
            Defines the outer edge of the arc, thus value 1 will not cause the arc to be bigger than possible.
            Later there might be a non-round PrimaryScale, and/or setter for absolute size. 
            Value should be between ]0,1]. values larger than 1 are technically possible, but the PrimaryScale will then take 
            more space than is available for it, and thus it will probably be mis-positioned and/or clipped. 
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Scale.RadiusBaseline">
            <summary>
             Radius the PrimaryScale expects to have at it's disposal. 
             Uses that space exactly, if the RadiusFactor is 1.0 (default).
            </summary>
            causes call to \ref HandleRadiusChange() if value changes
        </member>
        <member name="T:Arction.Gauges.GaugeThemeEnum">
            <summary>
            Enumration of possible gauge themes. 
            </summary>
        </member>
        <member name="T:Arction.Gauges.Gauge">
            <summary>
            Gauge element, that can contain multiple Scales. 
            The scale objects handle the presentation of data, dials, ticks etc. 
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:Arction.Gauges.Gauge.#ctor(System.Boolean)">
            <summary>
             Secondary constructor for gauge, to be used in code when 
             the gauge should try to fill the parent element fully. 
            </summary>
            <param name="FillParent"></param>
        </member>
        <member name="F:Arction.Gauges.Gauge.AngleBeginProperty">
            <summary>Starting angle of the Gauge. DependencyProperty of the AngleBeging property.</summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.AngleEndProperty">
            <summary>Ending angle of the Gauge. DependencyProperty of the AngleEnd property.</summary>
        </member>
        <member name="M:Arction.Gauges.Gauge.HandleAngleChaged(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Handles changes in the AngleBeginProperty and AngleEndProperty.
            </summary>
            <param name="sender">ignored</param>
            <param name="e">Must be either m_AngleEnd or m_AngleBegin.</param>
        </member>
        <member name="F:Arction.Gauges.Gauge.AdjacentPaddingProperty">
            <summary>Padding between the legs of the gauge, and the contained scales. DependencyProperty of the AdjacentPadding property.</summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.ArcPaddingProperty">
            <summary>Padding between the arc of the gauge and the contained scales. DependencyProperty of the ArcPadding property.</summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.StrokeThicknessProperty">
            <summary>Thickness of the border of the gauge. DependencyProperty of the StrokeThickness property.</summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.StrokeProperty">
            <summary>Brush (or color) of the border of the gauge. DependencyProperty of the Stroke property.</summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.FillProperty">
            <summary>Filling of the gauge.. DependencyProperty of the Fill property.</summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.m_SelfCreatePS">
            <summary>
             Defines if the m_PrimaryScale is created by this class or if it's 
             given. If reference exist, it's created by this class.
            </summary>
        </member>
        <member name="M:Arction.Gauges.Gauge.InitBorder">
            <summary>
             Initializes border object and it's settings. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.LightDirectionProperty">
            <summary>Direction the light comes. Used in shading. DependencyProperty of the LightDirection property.</summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.ThemeProperty">
            <summary>Theme of the gauge. Used in shading. DependencyProperty of the Theme property.</summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.PrimaryScaleThemeProperty">
            <summary>The default theme of the primary scales. DependencyProperty of the PrimaryScaleTheme property.</summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.SecondaryScalesThemeProperty">
            <summary>The default theme of the secondary scales. DependencyProperty of the SecondaryScalesTheme property.</summary>
        </member>
        <member name="M:Arction.Gauges.Gauge.FillParent">
            <summary>
             Removes set width and height definitions, making it easier to 
             handle the item in code. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.Gauge.MeasureOverride(System.Windows.Size)">
            <summary>
            Overridden MeasureOverride method.
            </summary>
            <param name="availableSize"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Gauge.ArrangeOverride(System.Windows.Size)">
            <summary>
             Arranges the items properly. 
            </summary>
            <remarks>
             Uses just enough space, not necessarilly the whole space. 
             Current implementation tries too much optimization, as the optimization and value caching might actually be slower than just calculating the data every time. 
            </remarks>
            <param name="finalSize"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.Gauge.SetScaleInfo(Arction.Gauges.Scale,Arction.Gauges.Geo.VecS)">
            <summary>
            Forms the layout information of the given scale and sets it for the 
            panel.
            </summary>
            <param name="scale"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Arction.Gauges.Gauge.HandleBorderGeometyryUpdated(System.Object,System.EventArgs)">
            <summary>
             callback for the borders GeometryUpdated event. 
            </summary>
            <remarks>
            <para> Delivers borders new (assumed to have changed) contentradius for the scales.
            </para>
            <para>Scales will invalidate their measure on setting of the value, if it causes changes.</para>
            </remarks>
            <param name="sender">Ignored</param>
            <param name="e">Ignored</param>
        </member>
        <member name="M:Arction.Gauges.Gauge.HandleScaleGeomChange(System.Object,System.EventArgs)">
            <summary>
             Callback for the scales geometryChanged event.
             Invalidates measure.
            </summary>
            <remarks>
             <para></para>
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.Gauge.HandleSecScalesChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
             Handles changes in the m_SecScale object. 
            </summary>
            <remarks>
            <para>Not the changes of the object itself, those are handled by the setter.</para>
            <para></para>
            </remarks>
            
            <param name="sender">Ignrred</param>
            <param name="e">Ignrred</param>
        </member>
        <member name="M:Arction.Gauges.Gauge.InitScaleSettings(Arction.Gauges.Scale,System.Boolean)">
            <summary>
             Initializes given scale's settings.
            </summary>
            <param name="scale"></param>
            <param name="Primary"></param>
        </member>
        <member name="M:Arction.Gauges.Gauge.DeInitScaleSettings(Arction.Gauges.Scale,System.Boolean)">
            <summary>
             Deinitializes the given scales settings.
            </summary>
            <param name="scale"></param>
            <param name="Primary"></param>
        </member>
        <member name="M:Arction.Gauges.Gauge.AddDial(Arction.Gauges.Dials.Dial)">
            <summary>
             Adds the given Dial object for the gauge to be handled as its own 
             child, and thus measured / arranged by the Gauge. 
             </summary>
        </member>
        <member name="M:Arction.Gauges.Gauge.RemoveDial(Arction.Gauges.Dials.Dial)">
            <summary>
             Removes the given Dial object for the gauge to be handled as its own 
             child, and thus measured / arranged by the Gauge. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.m_ParentControl">
            <summary>
             Parent GaugeControl element.
            </summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.m_Border">
            <summary>
             The border element of the gauge. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.m_Panel">
            <summary>
             Internal panel containing all of the UI objects. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.m_Dials">
            <summary>
             Panel of Dials. The ownership is really on the PrimaryScale elements, but we have the references so we can
             properly hadle their arrangement and measurement.
            </summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.m_Area">
            <summary>
             Angles and sweeping direction of the gauge and its border. 
             Shared with the border element. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.m_MaxSize">
            <summary>
             Basis for the last measurement round, meaning max size given for the object on last measure round. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.m_ReqSize">
            <summary>
             Last returned desired size from the MeasureOverride. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.m_givenSize">
            <summary>
             Size given as available space on Measure. 
            </summary>
            <remarks>
             Currently only set, never actually used. 
            </remarks>
        </member>
        <member name="F:Arction.Gauges.Gauge.m_CenterMarker">
            @}
        </member>
        <member name="F:Arction.Gauges.Gauge.d_VecDial">
            <summary>
             Debugging vector for showing how different positions are calculated
            </summary>
        </member>
        <member name="F:Arction.Gauges.Gauge.m_ThemeDic">
            <summary>
             Dictionary containing styles and templates for currently selected theme.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Gauge.AngleBegin">
            <summary>
             Starting angle of the Gauge.
            </summary>
            <remarks>
             <para>Defines the starting angle of the gauge area. If this is same as 
             the AngleEnd, a full circle gauge is drawn.</para>
             <para>The angles are in degrees, and the sweeping directino is 
             clockwise.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.AngleEnd">
            <summary>
             Ending angle of the Gauge.
            </summary>
            <remarks>
             <para>Defines the ending angle of the gauge area. If this is same 
             as the AngleEnd, a full circle gauge is drawn. </para>
             <para>The angles are in degrees, and the sweeping directino is 
             clockwise.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.AdjacentPadding">
            <summary>
             Padding between the "legs" of the gauge, and the contained scales. 
            </summary>
            <remarks>
             <para>Has no effect if the gauge is drawn as full-circle.</para>
             <para>Value is in WPF virtual pixels</para>
             <para>Also see ArcPadding property.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.ArcPadding">
            <summary>
             Padding between the arc of the gauge and the contained scales. 
            </summary>
            <remarks>
             <para>Value is in WPF virtual pixels</para>
             <para>Also see AdjacentePadding property.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.StrokeThickness">
            <summary>
             Thickness of the border of the gauge. 
            </summary>
            <remarks>
             <para>Value is in WPF virtual pixels</para>
             <para>The color of the border can be controlled throug Stroke property.</para>
             <para>Note that the Control.BorderBrush and Control.BorderStroke control the 
             WPF's rectangle border, and should not be used. </para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.Stroke">
            <summary>
             Brush (or color) of the border of the gauge. 
            </summary>
            <remarks>
             <para>The thickness of the border can be controlled throug StrokeThickness property.</para>
             <para>Note that the Control.BorderBrush and Control.BorderStroke control the 
             WPF's rectangle border, and should not be used. </para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.Fill">
            <summary>
             Filling of the gauge.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.Raised">
            <summary>
             Defines if the border of the gauge is raised or lowered, affecting 
             shadows. Advanced shadow system is not in use, and thus this 
             property does nothing for now. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.Gauge.ContentCenter">
            <summary>
             Centering point of the gauge, that the different items are drawn 
             around to. Basis for the positioning of items in gauge. 
            </summary>
            <remarks>
             <para>The point is in relative coordinates of to the left-top 
             corner of the gauge's area. </para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.RoundBorder">
            <summary>
             Defines how to draw the border stroke at the AdjacentPadding area. 
             If true, the area is drawn as arc, if false a straight line is used. 
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.Resources">
            <summary>
             Overridden getter/setter of the Resources property.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Gauge.DefaultDial">
            <summary>
             Dial of the gauges PrimaryScale
            </summary>
        </member>
        <member name="P:Arction.Gauges.Gauge.PrimaryScale">
            <summary>
             Primary scale of the gauge. The system makes sure there is always
             a primary scale available. 
            </summary>
            <remarks>
             <para>Primary scale is normal scale, but it's guaranteed to always 
             exist. To increase the number of scales, insert new scales to 
             SecondaryScales list. </para>
             <para>Setting this causes the old PrimaryScale to become invalid and 
             unfunctioning.</para>
             <para>Setting the value to null will cause a default scale to be 
             created.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.SecondaryScales">
            <summary>
             List of secondary scales.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.ParentControl">
            <summary>
             Parent GaugeControl element of this Gauge. 
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.LightDirection">
            <summary>
             Direction the light is shining from. 
            </summary>
            <remarks>
            <para>Currently only affects the dials shadow direction. Later this 
            might be change to affect other aspects of the gauge as well.</para>
            <para>Values are currently in radians, in XAML the values are 
            automatically converted from degrees.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.Theme">
            <summary>
             Theme of the gauge. 
            </summary>
            <remarks>
            <para>The theme of the gauge defines the default settings for gauge and 
            scales, in effect allowing different outlooks on a simple selection. The ClearGauge is special from others, 
            that it removes most of the settings and the gauge has no visual presentation. </para>
            <para>The scales has matching proeprty, allowing per-scale themes. The scales settings are not 
            directly controlled through the gauge, but through SecondaryScalesTheme and PrimaryScaleTheme properties.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.PrimaryScaleTheme">
            <summary>
             The default theme of the primary scales.
            </summary>
            <remarks>
            <para>Note that the direct setting of the scales theme property overrides this property.</para>
            </remarks>
        </member>
        <member name="P:Arction.Gauges.Gauge.SecondaryScalesTheme">
            <summary>
             The default theme of the secondary scales.
            </summary>
            <remarks>
            <para>Note that the direct setting of the scales theme property overrides this property. This 
            nowever allows one to set the default for all the secondary scales on one statement, and then overriding 
            that setting in specific scales.</para>
            </remarks>
        </member>
        <member name="T:Arction.Gauges.GaugeControl">
            <summary>
            Gauge element.
            </summary>
            \internal
            \todo Add properties:
             * DefaultDial
             * PrimaryScale
             * Value
             * DataSource
             * PrimaryScale list
             * DialList (possibly, only useful if the PrimaryScale has more than one Dial). 
            \todo Add inheriting properties.. whatever.
             * Position (for gauges) as something that defines if it's _objective_ or absolute
             * Size (for gauges, then again, they could have their own) as something that defines if it's objective or absolute
            \todo Add custom arrangement/measurement stuff, ordering internal elements.
            \todo Change the properties to dependencyproperties so they can be controlled from designer
        </member>
        <member name="M:Arction.Gauges.GaugeControl.#ctor(System.Boolean)">
            <summary>
             A constructor that can be used to automatically call the 
             InitDefTemplate method. 
            </summary>
            <param name="InitDefaultTemplate"></param>
        </member>
        <member name="M:Arction.Gauges.GaugeControl.InitDefTemplate">
            <summary>
             Sets item to use the default template. 
             Sets the Template property locally (styles can not modify it 
             before the value is cleared) to a default template value. 
            </summary>
            <remarks>
            This method can be accessed using construcor paremeter as well.
            Later a DP will replace this, that can be used to determine the
            default / activated template form a preset list of templates. 
            </remarks>
        </member>
        <member name="F:Arction.Gauges.GaugeControl.m_Cont">
            <summary>
             Container for everything visual in the gauge. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.GaugeControl.m_Gauges">
            <summary>
             List of all the axes in the gauge. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.GaugeControl.m_PrimaryGauge">
            <summary>
             Default PrimaryScale of the gauge
            </summary>
        </member>
        <member name="F:Arction.Gauges.GaugeControl.m_LayoutDic">
            <summary>
             Dictionary containing styles and templates for currently selected theme.
            </summary>
        </member>
        <member name="P:Arction.Gauges.GaugeControl.PrimaryGauge">
            <summary>
            Default gauge element of the gaugecontrol. 
            There is always guaranteed to exist at least one gauge in the control. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.GaugeControl.PrimaryDial">
            <summary>
            Default Dial of the gaugecontrols default Gauge. 
            There is always guaranteed to be at least one of these. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Arction.Gauges.TicksLine" -->
        <member name="M:Arction.Gauges.TicksLine.OnApplyTemplate">
            <summary>
             Initialized the system to use the new template. 
            </summary>
            \internal 
            At this position of code as it's part of the init phase. Run 
            indirectly from constructor.
        </member>
        <member name="M:Arction.Gauges.TicksLine.Create(Arction.Gauges.Ticks.TickType)">
            <summary>
             Creates some of the known subtypes of TicksLine based on the tiven TickType. 
             For TickType.Undefined, a normal TicksLine is created. 
            </summary>
            
            <Remarks>
             <p>Used at least by the PrimaryScale to create the default items for different 
             TicksLine properties.</p>
             <p>All of the TicksLine objects behave identically, but they having 
             different types makes it possible to identify them in styles. </p>
             <p>Style triggers are not used for that purpose as they do not 
             exit on Silverlight, and VisualStateManager is not used as 
             TicksLine is not a control class (yet)</p>
             <p>As there is no DialTicksLine class (yet), a normal TicksLine
             object is created for it. Dial ticks are kept on 
             CustomTicksLines</p>
            </Remarks>
            
            <throws>
             NotImplementedException for unrecognized TickType parameters.
            </throws>
            
            <param name="type">Type of the TicksLine subtype to create.</param>
            \todo Copy the remarks to some more findable position, a 
            separate page preferably. 
        </member>
        <member name="M:Arction.Gauges.TicksLine.Init">
            <summary>
             If we come here, we can safely assume that the ticks list has changed. 
            </summary>
        </member>
        <member name="M:Arction.Gauges.TicksLine.CleanUpTicks">
            <summary>
             Cleans up / rmeoves all of our owned items. Especially all the UI 
             objects. 
            </summary>
            <remarks>
             Called at least on tick settings for the old ticklists elements. 
            </remarks>
        </member>
        <member name="M:Arction.Gauges.TicksLine.ResetLabelReserveSize(System.Boolean)">
            <summary>
             Re-calculates the label reservesize, even if the 
             AutodetermineLabelSize prohibits that. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Arction.Gauges.TicksLine.ResetToDefaultSettings">
            <summary>
             To be called when the non-stylable settings / properties (non-dp) 
             should be resetted to their default values. 
            </summary>
            <remarks>
             This should especially be callaed when scales theme changes, as 
             the settings are otherwise carried from theme to an other. 
            </remarks>
        </member>
        <member name="M:Arction.Gauges.TicksLine.CalcLabelRect(Arction.Gauges.Tick)">
            <summary>
             Determines the rect to arrange the given tick. 
            </summary>
            <param name="t"></param>
            <returns></returns>
            \note This function currently assumes that the texts are to be positioned on the outer edge of the PrimaryScale 
            line. 
            \note The current implementation is quite slow. It's possible to optimize this greatly.
            \note This function can not handle multiround elements. 
        </member>
        <member name="M:Arction.Gauges.TicksLine.GetMaxRadExtra">
            <summary>
            Calculates the maximum required offset/extra space that needs to be added to the radius, so that we get the required space. 
            Kind of a MinSize, except internally calculated, not settable, and not necessarilly exact
            </summary>
            <remarks>
            <para>With rectangle like items we might change this to return size. </para> 
            <para>Currently this is the reserved larger dim of the label's reseved size + the label offset. </para>
            </remarks>
        </member>
        <member name="M:Arction.Gauges.TicksLine.GetMinRad">
            <summary>
            Calculates the minumum required radius of the arc where the 
            elements of TicksLine can still be drawn (does not guarantee 
            that the labels and itmes do not overlap). 
            </summary>
            <remarks>
            With rectangle like items we might change this to return size. 
            </remarks>
        </member>
        <member name="M:Arction.Gauges.TicksLine.GetReqRad(System.Windows.Size)">
            <summary>
             Calculates the radius of the arc so that the TicksLine can fit 
             into the given size. 
            </summary>
            <remarks>
            Used as a part of the higher level layout, so that the PrimaryScale does not
            have to run the whole measure round. 
            </remarks>
            <param name="UseSize"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.TicksLine.UpdateMaxRadExtra" -->
        <member name="M:Arction.Gauges.TicksLine.UpdateLabelReserve(Arction.Gauges.Tick,System.Windows.Size)">
            <summary>
             Tries to update m_LabelReserveSize and either (or both) 
             m_LabelReserveSrcH / m_LabelReserveSrcW from the given tick. 
            </summary>
            <remarks>
            <para>Note that this method does not cause signaling of the change.
            The caller is responsible of the actions that ought to be taken 
            when the reserved label change is modified.</para>
            </remarks>
            <param name="t">Tick to compare to the reserver source ticks.</param>
            <param name="cs">Calculated size of the tics label. 
            Ref so that it wont create new size. The parameter is not modified.</param>
            <returns>True if either direction source was modified.</returns>
            \internal
            cs taken as reference to prevent copy, but seems to be done for 
            nothing, as we must just copy, copy, copy and copy...allways just 
            copy stuff with this shitty little bastard language. 
        </member>
        <member name="M:Arction.Gauges.TicksLine.CalcLabelSize(Arction.Gauges.Tick)">
            <summary>
             Calculates how much space is required for the labels around the PrimaryScale. 
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:Arction.Gauges.TicksLine.InitTick(Arction.Gauges.Tick)">
            <summary>
             Initialized given tics UI elements. 
             Does not affect parent/child realtionships.
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Arction.Gauges.TicksLine.DeInitTick(Arction.Gauges.Tick)">
            <summary>
             DeInitializes given tics UI elements. 
             In effect, removes all settings/items that has been done to the 
             tick by InitTick method (expects them to be done by it). 
            </summary>
            <remarks>
            Note that the method expects that the tick modifications will not
            cause callbackst to this object.
            </remarks>
            <param name="tick">Tick to deinitialize</param>
        </member>
        <member name="M:Arction.Gauges.TicksLine.UpdateAllTicks(System.Boolean)">
            <summary>
             Tries to update all the ticks.
            </summary>
            <param name="InvalidateParentMeasure">If true, will cause parent's
            measure invalidation also.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Arction.Gauges.TicksLine.UpdateAllTickLabels(System.Boolean)" -->
        <member name="M:Arction.Gauges.TicksLine.UpdateTick(Arction.Gauges.Tick)">
            <summary>
             Updates ticks visual settings, like labels text and location.
             Will require measure or at least arrange round after this, 
             but does not request it, so that this can be called during that call.
            </summary>
            <remarks>
            Currently does not care if the item is marked as dirty
            </remarks>
            <param name="tick"></param>
        </member>
        <member name="M:Arction.Gauges.TicksLine.UpdateTickLabel(Arction.Gauges.Tick)">
            <summary>
             Updates given ticks label, including the required label size. 
            </summary>
            <remarks>
            </remarks>
            <returns>True if some modification was done</returns>
            \internal Todo: we really need to store information that allows us to do these upkeep jobs only for really modified items. 
        </member>
        <member name="M:Arction.Gauges.TicksLine.UpdateLabelSize(Arction.Gauges.Tick,System.Boolean)">
            <summary>
             Re-Calculates given ticks label value change effect for m_LabelRadExtra. 
             If no tick is given, the value if fully re-calculated. 
            </summary>
            <remarks>
            It might be faster to keep ordered list of thickneses, or heap or something like that. 
            </remarks>
            <param name="tick"></param>
            <returns>True if the either m_LabSizeReserveH/W has been changed</returns>
            \bug Causes no notification of the parent, as this will cause measure changes. 
        </member>
        <member name="M:Arction.Gauges.TicksLine.CalcLabelRotAngle(System.Double,Arction.Gauges.LabelRotType)">
            <summary>
             Calculates the rontation to set for the label for the given settings. 
            </summary>
            <param name="AngD">Angle of the labesl TICK in degrees.</param>
            <param name="LabelRotType">Rotation type to use.</param>
            <returns>Angle of the rotation to use in degrees.</returns>
        </member>
        <member name="M:Arction.Gauges.TicksLine.MeasureOverride(System.Windows.Size)">
            \name Layout functions
        </member>
        <member name="M:Arction.Gauges.TicksLine.HandleOffsetChanged(System.Object,Arction.DProp.DPChangedEventArgs)">
            \name Property changed event handlers.
        </member>
        <member name="M:Arction.Gauges.TicksLine.HandleLabelFormatChanged(System.Object,Arction.DProp.DPChangedEventArgs)">
            <summary>
             Callback function of the m_LabelFormat variable (LabelFormatProperty property).
            </summary>
            <remarks>
            Note that this will cause recalculation of label reserve size.</remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.TicksLine.HandleTickModfication(System.Object,Arction.Gauges.Ticks.TickModifiedEventArg)">
            <summary>
            Handles situations where the ticks list reports changes at some tick.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            \todo special treatment for Dial tick, as we do not want it to do something wierd, we should
            handle those arranges on some special way, as it's quite costly to do the whole arrange round. 
        </member>
        <member name="M:Arction.Gauges.TicksLine.HandleListChanges(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
             Called when list ticklist has modifications
            </summary>
            <remarks>
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Arction.Gauges.TicksLine.CheckFontChanges">
            \name Helper methods
        </member>
        <member name="F:Arction.Gauges.TicksLine.m_Geo">
            \name Private elements
        </member>
        <member name="P:Arction.Gauges.TicksLine.TickList">
            \name Internal items accessors
        </member>
        <member name="P:Arction.Gauges.TicksLine.OffsetA">
            <summary>
            </summary>
            <remarks>
             At some point a Range should be changed to RangeStruct and a new Range 
             implemented with dependencyvariables, and that set as Offset here.
            </remarks>
        </member>
        <member name="P:Arction.Gauges.TicksLine.Radius">
            \name Positioning properties
        </member>
        <member name="P:Arction.Gauges.TicksLine.ContentCenter">
            <summary>
             Getter of the coordinates (as vector from lt-corner) of the content 
             center.
             Currently this is the center of the virtual circle, of radius m_Radius.
            </summary>
            \internal 
            \todo Set to non-browsable after debugging. 
        </member>
        <member name="P:Arction.Gauges.TicksLine.LabelBrush">
            <summary>
             Brush for all the values. 
            </summary>
               
        </member>
        <member name="P:Arction.Gauges.TicksLine.LabelRotation">
            <summary>
             
            </summary>
            <remarks>
            Value in degrees, values increase counter-clockwise, 0 angle at right.
            </remarks>
        </member>
        <member name="P:Arction.Gauges.TicksLine.ReserverdLabelSize">
            <summary>
             The space to reserve for a single label element. 
             The actual effect of the size depends of other parameters. 
             If the label is inside the arc, it practically has no effect what 
             so ever. 
            </summary>
            <remarks>
            Setting this will automaticly switch off the label size autodetemination.
            If the autodetermination is on, this will return the result of that system. 
            </remarks>
            \internal
            \todo Change to ReservedLabelRadius? Yes, we handle some parts of the size 
            requirements as rect, but mostly it's radius. 
        </member>
        <member name="P:Arction.Gauges.TicksLine.AutodetermineLabelSize">
            <summary>
             Defines how the label size reserve is determined
            </summary>
        </member>
        <member name="P:Arction.Gauges.TicksLine.KeepLabelsInArea">
            <summary>
             Defines if the labels are to be considered as part of the TicksLine. 
             If false, the line will not reserver any space for them on the arrange. 
            </summary>
        </member>
        <member name="P:Arction.Gauges.TicksLine.LabelPositionType">
            <summary>
             Defines how the labels are positioned
            </summary>
        </member>
        <member name="P:Arction.Gauges.TicksLine.LabelRotationType">
            <summary>
             Defines how the labels are rotated
            </summary>
        </member>
        <member name="P:Arction.Gauges.TicksLine.LabelOffset">
            <summary>
             Offset (padding, inner margin) of the label, speficying the space between the label and the PrimaryScale.
            </summary>
            
            <remarks>
            polarity speficies if the label is positioned on the inside or the outside of the PrimaryScale. 
            This and the LableInside property are directly linked.
            </remarks>
            
            \note The positioning system does not yet know the thicknes of the arc line, thus can not 
            take that into account automatically, and only this is used. 
            \bug Changing this does not cause recalculation of max rad offset (or what ever the name was) and parent notification.
        </member>
        <member name="P:Arction.Gauges.TicksLine.LabelInside">
            <summary>
             Describes if the label is positioned outside or the inside of the arcline. Identical to 
             polarity of the Offset (true matches negative offset) but cached value on the time 
             setting the of offset.
            </summary>
            \bug Chaning this does not cause recalculation of max rad offset (or what ever the name was) and parent notification.
        </member>
        <!-- Badly formed XML comment ignored for member "P:Arction.Gauges.TicksLine.LabelPartOfSize" -->
        <member name="P:Arction.Gauges.TicksLine.LabelAffectsSize">
            <summary>
             Determines if the label really ought to affect DesiderdSize. 
             Combines LabelsEnabled and LabelPartOfSize properties.
             Note that this does not mean that the label really affects size, 
             but that it might, as it does either limit the size as minimumsize, 
             or add an extra layer to the tiskline and thus increases it's size. 
            </summary>
        </member>
        <member name="T:Arction.Gauges.LabelReserveSizeDT">
            <summary>
             Defines options for TicksLine.AutodetermineLabelSize property. 
            </summary>
        </member>
        <member name="F:Arction.Gauges.LabelReserveSizeDT.Manual">
            <summary>
             Manual setting only, no automatic determination
            </summary>
        </member>
        <member name="F:Arction.Gauges.LabelReserveSizeDT.Increase">
            <summary>
             Labels size reserve is automatically increased.
            </summary>
        </member>
        <member name="F:Arction.Gauges.LabelReserveSizeDT.FullAuto">
            <summary>
             Labels size reserve is automatically increased and decreased.
            </summary>
        </member>
        <member name="F:Arction.Gauges.LabelReserveSizeDT.AutoResetOnFontChange">
            <summary>
             Labels size reserve is automatically resetted on font changes.
            </summary>
        </member>
        <member name="F:Arction.Gauges.LabelPosType.ExactCenter">
            <summary>
             The Offset specifies directly the center of the label. 
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="F:Arction.Gauges.LabelPosType.ClosestCorner">
            <Summary>
            The closest corner of the label-rect is positioned to the offset 
            point</Summary>
        </member>
        <member name="F:Arction.Gauges.LabelPosType.ClosestEdge">
            <summary>
             The center of the label is at the line from the center and 
             the closest (to the radius) edge of the label rect is at the 
             offset away form the radius circle. 
            </summary>
            <remarks>
             <para>As a result, each label should look like it's the same lengt away
             form the radius, effective as an arc. </para>
             <para>Does not work so well with rotations, as the position is 
             calculated for an unrotated label.</para>
            </remarks>
        </member>
        <member name="T:Arction.Gauges.LabelRotType">
            <summary>
             Defines the types the label can be rotated in relation to the tick angle.
            </summary>
        </member>
        <member name="F:Arction.Gauges.LabelRotType.None">
            <Summary>
            No rotation 
            </Summary>
        </member>
        <member name="F:Arction.Gauges.LabelRotType.Inside">
            <Summary>
            The normal rotation mode, the label's text faces inside the gauge.
            </Summary>
        </member>
        <member name="F:Arction.Gauges.LabelRotType.Outside">
            <Summary>
            Label's text faces outside of the gauge. Same as Inside + 180.
            </Summary>
        </member>
        <member name="F:Arction.Gauges.LabelRotType.Straight">
            <Summary>
            The angle of the label is same as the ticks. 
            </Summary>
        </member>
        <member name="F:Arction.Gauges.LabelRotType.InsideDown">
            <Summary>
            The label is rotated as with option Inside, but the rotation angle
            is flipped when the text would be upside down, to prevent that 
            situatuation. 
            </Summary>
            <remarks>
             This does not prevent the text being upside down though, as this
             does NOT affect the LabelRotation property. 
            </remarks>
        </member>
        <member name="T:Arction.Gauges.MajorTicksLine">
            <summary>
            Primary scale line with ticks.
            </summary>
        </member>
        <member name="T:Arction.Gauges.MinorTicksLine">
            <summary>
            Secondary scale line with ticks.
            </summary>
        </member>
        <member name="T:Arction.Gauges.TertiaryTicksLine">
            <summary>
            Tertiary scale line with ticks.
            </summary>
        </member>
        <member name="T:Arction.Gauges.CustomTicksLine">
            <summary>
            Custom scale line with ticks.
            </summary>
        </member>
        <member name="T:Arction.Needles.DullNeedle">
            <summary>
             
            </summary>
            <remarks>
            <h3>About size definition with Dial:</h3>
            When using the Dial element with Dial, the size's are only realtive to each other, and has no real meaning. 
            The final size is determined by the Dial, and the needle is ValueMapperd to that final size by the Dial object.
            </remarks>
        </member>
        <member name="M:Arction.Needles.DullNeedle.GetColorName(System.Int32)">
            <summary>
             Getter of the color name / description
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Needles.DullNeedle.SetColor(System.Int32,System.Windows.Media.Color)">
            <summary>
             Setter of a color.
            </summary>
            <param name="i"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="P:Arction.Needles.DullNeedle.ColorCount">
            <summary>
             Getter of the supported color count that the needle uses. 
            </summary>
        </member>
        <member name="T:Arction.Needles.SimpleCompassNeedle">
            <summary>
             Extremely simple compas needle consisting of two tringle of which 
             dimensions the user can control. 
             -- add image here -- 
            </summary>
            <remarks>
            <h3>About size definition with Dial:</h3>
            When using the Dial element with Dial, the size's are only realtive to each other, and has no real meaning. 
            The final size is determined by the Dial, and the needle is ValueMapperd to that final size by the Dial object.
            </remarks>
            \todo implement ColorNeedle base class
        </member>
        <member name="M:Arction.Needles.SimpleCompassNeedle.GetColorName(System.Int32)">
            <summary>
             Getter of the color name / description
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Needles.SimpleCompassNeedle.SetColor(System.Int32,System.Windows.Media.Color)">
            <summary>
             Setter of a color.
            </summary>
            <param name="i"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="P:Arction.Needles.SimpleCompassNeedle.ColorCount">
            <summary>
             Getter of the supported color count that the needle uses. 
            </summary>
        </member>
        <member name="T:Arction.Needles.WideNeedle">
            <summary>
            WideNeedle
            </summary>
        </member>
        <member name="M:Arction.Needles.WideNeedle.GetColorName(System.Int32)">
            <summary>
             Getter of the color name / description
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Needles.WideNeedle.SetColor(System.Int32,System.Windows.Media.Color)">
            <summary>
             Setter of a color.
            </summary>
            <param name="i"></param>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Arction.Needles.WideNeedle.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="P:Arction.Needles.WideNeedle.ColorCount">
            <summary>
             Getter of the supported color count that the needle uses. 
            </summary>
        </member>
        <member name="T:Arction.Gauges.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Arction.Gauges.Properties.Resources.TestNeedle4">
             <summary>
               Looks up a localized string similar to &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
                &lt;!--This file is compatible with Silverlight--&gt;
            &lt;Canvas xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; Name=&quot;svg3367n&quot; Width=&quot;620.10559&quot; Height=&quot;104.4473&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&gt;
                &lt;Canvas.RenderTransform&gt;
                    &lt;TranslateTransform X=&quot;0&quot; Y=&quot;0&quot;/&gt;
                &lt;/Canvas.RenderTransform&gt;
                &lt;Canvas.Resources&gt;
                    &lt;LinearGradientBrush x:Key=&quot;linearGradient4147&quot; MappingMode=&quot;RelativeToBoundingBox&quot; StartPoint=&quot;0,0&quot; [rest of string was truncated]&quot;;.
             </summary>
        </member>
    </members>
</doc>
